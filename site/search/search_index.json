{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index Team Members vilsu / vilsu cebolinha / edu eyz / eyz Useful Links Tiagodfs's Template CP-Algorithms AtCoder Problems Dynamic A2OJ","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"#team-members","text":"vilsu / vilsu cebolinha / edu eyz / eyz","title":"Team Members"},{"location":"#useful-links","text":"Tiagodfs's Template CP-Algorithms AtCoder Problems Dynamic A2OJ","title":"Useful Links"},{"location":"dfslowlink/","text":"DFS Lowlink Technique for finding bridges and articulation points. Video explaining the concept: YouTube - DFS Lowlink . Implementation Problems SPOJ - Manuten\u00e7\u00e3o - Finding articulation points SPOJ - Critical Edges - Finding bridges","title":"DFS Lowlink"},{"location":"dfslowlink/#dfs-lowlink","text":"Technique for finding bridges and articulation points. Video explaining the concept: YouTube - DFS Lowlink .","title":"DFS Lowlink"},{"location":"dfslowlink/#implementation","text":"","title":"Implementation"},{"location":"dfslowlink/#problems","text":"SPOJ - Manuten\u00e7\u00e3o - Finding articulation points SPOJ - Critical Edges - Finding bridges","title":"Problems"},{"location":"dsu/","text":"Disjoint Set Union Implementation Warning The implementation uses indices [0, n-1] DSU struct DSU { vector < int > p , s ; DSU ( int n ) { p . assign ( n , -1 ), s . assign ( n , 1 ); } int find ( int v ) { if ( p [ v ] == -1 ) return v ; return p [ v ] = find ( p [ v ]); } void join ( int a , int b ) { a = find ( a ), b = find ( b ); if ( a != b ) { if ( s [ a ] < s [ b ]) swap ( a , b ); p [ b ] = a , s [ a ] += s [ b ]; } } }; This implementation can be tested on Library Checker - Unionfind . [Submission] Problems Codeforces 25D - Roads Not Only in Berland","title":"Disjoint Set Union"},{"location":"dsu/#disjoint-set-union","text":"","title":"Disjoint Set Union"},{"location":"dsu/#implementation","text":"Warning The implementation uses indices [0, n-1] DSU struct DSU { vector < int > p , s ; DSU ( int n ) { p . assign ( n , -1 ), s . assign ( n , 1 ); } int find ( int v ) { if ( p [ v ] == -1 ) return v ; return p [ v ] = find ( p [ v ]); } void join ( int a , int b ) { a = find ( a ), b = find ( b ); if ( a != b ) { if ( s [ a ] < s [ b ]) swap ( a , b ); p [ b ] = a , s [ a ] += s [ b ]; } } }; This implementation can be tested on Library Checker - Unionfind . [Submission]","title":"Implementation"},{"location":"dsu/#problems","text":"Codeforces 25D - Roads Not Only in Berland","title":"Problems"},{"location":"seg/","text":"Segment Tree Implemention Segment Tree template < typename T > class SegmentTree { int n ; T neutral ; V < T > t ; std :: function < T ( T , T ) > merge ; public : SegmentTree ( int n , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = n ; this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); } SegmentTree ( V < T > & v , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = v . size (); this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); loop ( i , n ) t [ i + n ] = v [ i ]; build (); } void build () { for ( int i = n -1 ; i > 0 ; i -- ) t [ i ] = merge ( t [ 2 * i ], t [ 2 * i + 1 ]); } T query ( int l , int r ) { T rl = neutral , rr = neutral ; for ( l += n , r += n + 1 ; l < r ; l /= 2 , r /= 2 ) { if ( l & 1 ) rl = merge ( rl , t [ l ++ ]); if ( r & 1 ) rr = merge ( t [ -- r ], rr ); } return merge ( rl , rr ); } void update ( int p , T val ) { for ( t [ p += n ] = val ; p > 1 ; p /= 2 ) t [ p / 2 ] = merge ( t [ min ( p , p ^ 1 )], t [ max ( p , p ^ 1 )]); } }; Usage example // Lambda macro #define L2(res ...) [](auto x, auto y){ return res; } // Addition Seg SegmentTree < int > seg_add ( n , 0 , L2 ( x + y )); // Maximum Seg SegmentTree < int > seg_max ( n , - INF , L2 ( max ( x , y ))); // Minimum and Maximum Seg SegmentTree < ii > seg_minmax ( n , { INF , - INF }, L2 ( min ( x . ff , y . ff ), max ( x . ss , y . ss )));","title":"Segment Tree"},{"location":"seg/#segment-tree","text":"","title":"Segment Tree"},{"location":"seg/#implemention","text":"Segment Tree template < typename T > class SegmentTree { int n ; T neutral ; V < T > t ; std :: function < T ( T , T ) > merge ; public : SegmentTree ( int n , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = n ; this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); } SegmentTree ( V < T > & v , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = v . size (); this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); loop ( i , n ) t [ i + n ] = v [ i ]; build (); } void build () { for ( int i = n -1 ; i > 0 ; i -- ) t [ i ] = merge ( t [ 2 * i ], t [ 2 * i + 1 ]); } T query ( int l , int r ) { T rl = neutral , rr = neutral ; for ( l += n , r += n + 1 ; l < r ; l /= 2 , r /= 2 ) { if ( l & 1 ) rl = merge ( rl , t [ l ++ ]); if ( r & 1 ) rr = merge ( t [ -- r ], rr ); } return merge ( rl , rr ); } void update ( int p , T val ) { for ( t [ p += n ] = val ; p > 1 ; p /= 2 ) t [ p / 2 ] = merge ( t [ min ( p , p ^ 1 )], t [ max ( p , p ^ 1 )]); } }; Usage example // Lambda macro #define L2(res ...) [](auto x, auto y){ return res; } // Addition Seg SegmentTree < int > seg_add ( n , 0 , L2 ( x + y )); // Maximum Seg SegmentTree < int > seg_max ( n , - INF , L2 ( max ( x , y ))); // Minimum and Maximum Seg SegmentTree < ii > seg_minmax ( n , { INF , - INF }, L2 ( min ( x . ff , y . ff ), max ( x . ss , y . ss )));","title":"Implemention"},{"location":"template/","text":"Template Full Template Full template #include <bits/stdc++.h> using namespace std ; // Template (v1.3.1 - 2023-01-11) (codeforces:cebolinha, atcoder:edu) {{{ #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; template < class T > using ordered_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #define int long long #define fastio ios::sync_with_stdio(false); cin.tie(nullptr) template < class T > using V = vector < T > ; template < class T > using min_priority_queue = priority_queue < T , vector < T > , greater < T >> ; using ii = pair < int , int > ; using iii = tuple < int , int , int > ; using ll = long long ; #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend() #define pb push_back #define eb emplace_back #define mp make_pair #define ff first #define ss second #define nemo ><> #define loop(ii, n) for (int ii = 0; ii < (n); ii++) #define cond(c, t, f) ((c) ? (t) : (f)) #define mem(a, b) memset((a), (b), sizeof(a)) #define inbounds(x, l, r) ((l) <= (x) && (x) <= (r)) #define L1(res...) [&](auto x){ return res; } #define L2(res...) [&](auto x, auto y){ return res; } template < class T , class U > inline void miq ( T & a , U b ){ if ( a > b ) a = b ;} template < class T , class U > inline void maq ( T & a , U b ){ if ( a < b ) a = b ;} template < class T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < class T , class U > ostream & operator << ( ostream & os , pair < T , U > const & p ) { os << \"(\" << p . first << \" \" << p . second << \")\" ; return os ; } template < class T > ostream & operator << ( ostream & os , vector < T > const & v ) { for ( int i = 0 ; i < v . size (); i ++ ) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } template < class T , class U > ostream & operator << ( ostream & os , map < T , U > const & m ) { bool first = true ; for ( auto const & [ k , v ] : m ) { if ( ! first ) os << \" \" ; first = false ; os << \"{\" << k << \" : \" << v << \"}\" ; } return os ; } template < class T > ostream & operator << ( ostream & os , set < T > const & s ) { for ( auto it = s . begin (); it != s . end (); it ++ ) os << cond ( it != s . begin (), \" \" , \"\" ) << * it ; return os ; } template < class ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < class ... A > void out ( A const & ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < class ... A > void print ( A const & ... a ) { (( cout << a ), ...); } #define var(x) \"[\", #x, \" \", x, \"] \" template < class ... A > void db ( A const & ... a ) { (( cout << ( a )), ...); cout << endl ; } //}}} auto main () -> signed { fastio ; } Better I/O These three functions can be used to make cin and cout a little more ergonomic. Space at the end of out Out produces a space at the end of the line, before endl . Some online judges may complain about that. Happens a lot on sites like Beecrowd, UVa, and Codeforces Gyms. Better I/O template < typename ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < typename ... A > void out ( A ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < typename ... A > void print ( A ... a ) { (( cout << a ), ...); } Usage example in ( x , y , z ); // cin >> x >> y >> z out ( x , y , z ); // cout << x << \" \" << y << \" \" << z << \" \" << endl; print ( x , y , z ); // cout << x << y << z; Container I/O Very useful functions that allow you to read and output vectors in a compact way. Can be used with the \"Better I/O\" or regular \"iostream\" functions. Container I/O template < class T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < class T > ostream & operator << ( ostream & os , vector < T > v ) { loop ( i , sz ( v )) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } Usage examples V < int > v ( n ); in ( v ); out ( v ); V < int > v ( n ); cin >> v ; cout << v ; set < int > S { 1 , 2 , 3 }; out ( s ); Debug macro Prints a variable's name next to its name. Debug Macro #define var(x) \"[\", #x, \" \", x, \"] \" template < typename ... A > void db ( A ... a ) { (( cout << var ( a )), ...); cout << endl ; } Usage example int x = 5 ; db ( x ); // [x 5] V < int > v { 1 , 2 , 3 }; db ( v ); // [v 1 2 3] Pragmas Enables some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them. Pragmas #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\")","title":"Template"},{"location":"template/#template","text":"","title":"Template"},{"location":"template/#full-template","text":"Full template #include <bits/stdc++.h> using namespace std ; // Template (v1.3.1 - 2023-01-11) (codeforces:cebolinha, atcoder:edu) {{{ #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; template < class T > using ordered_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #define int long long #define fastio ios::sync_with_stdio(false); cin.tie(nullptr) template < class T > using V = vector < T > ; template < class T > using min_priority_queue = priority_queue < T , vector < T > , greater < T >> ; using ii = pair < int , int > ; using iii = tuple < int , int , int > ; using ll = long long ; #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend() #define pb push_back #define eb emplace_back #define mp make_pair #define ff first #define ss second #define nemo ><> #define loop(ii, n) for (int ii = 0; ii < (n); ii++) #define cond(c, t, f) ((c) ? (t) : (f)) #define mem(a, b) memset((a), (b), sizeof(a)) #define inbounds(x, l, r) ((l) <= (x) && (x) <= (r)) #define L1(res...) [&](auto x){ return res; } #define L2(res...) [&](auto x, auto y){ return res; } template < class T , class U > inline void miq ( T & a , U b ){ if ( a > b ) a = b ;} template < class T , class U > inline void maq ( T & a , U b ){ if ( a < b ) a = b ;} template < class T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < class T , class U > ostream & operator << ( ostream & os , pair < T , U > const & p ) { os << \"(\" << p . first << \" \" << p . second << \")\" ; return os ; } template < class T > ostream & operator << ( ostream & os , vector < T > const & v ) { for ( int i = 0 ; i < v . size (); i ++ ) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } template < class T , class U > ostream & operator << ( ostream & os , map < T , U > const & m ) { bool first = true ; for ( auto const & [ k , v ] : m ) { if ( ! first ) os << \" \" ; first = false ; os << \"{\" << k << \" : \" << v << \"}\" ; } return os ; } template < class T > ostream & operator << ( ostream & os , set < T > const & s ) { for ( auto it = s . begin (); it != s . end (); it ++ ) os << cond ( it != s . begin (), \" \" , \"\" ) << * it ; return os ; } template < class ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < class ... A > void out ( A const & ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < class ... A > void print ( A const & ... a ) { (( cout << a ), ...); } #define var(x) \"[\", #x, \" \", x, \"] \" template < class ... A > void db ( A const & ... a ) { (( cout << ( a )), ...); cout << endl ; } //}}} auto main () -> signed { fastio ; }","title":"Full Template"},{"location":"template/#better-io","text":"These three functions can be used to make cin and cout a little more ergonomic. Space at the end of out Out produces a space at the end of the line, before endl . Some online judges may complain about that. Happens a lot on sites like Beecrowd, UVa, and Codeforces Gyms. Better I/O template < typename ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < typename ... A > void out ( A ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < typename ... A > void print ( A ... a ) { (( cout << a ), ...); } Usage example in ( x , y , z ); // cin >> x >> y >> z out ( x , y , z ); // cout << x << \" \" << y << \" \" << z << \" \" << endl; print ( x , y , z ); // cout << x << y << z;","title":"Better I/O"},{"location":"template/#container-io","text":"Very useful functions that allow you to read and output vectors in a compact way. Can be used with the \"Better I/O\" or regular \"iostream\" functions. Container I/O template < class T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < class T > ostream & operator << ( ostream & os , vector < T > v ) { loop ( i , sz ( v )) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } Usage examples V < int > v ( n ); in ( v ); out ( v ); V < int > v ( n ); cin >> v ; cout << v ; set < int > S { 1 , 2 , 3 }; out ( s );","title":"Container I/O"},{"location":"template/#debug-macro","text":"Prints a variable's name next to its name. Debug Macro #define var(x) \"[\", #x, \" \", x, \"] \" template < typename ... A > void db ( A ... a ) { (( cout << var ( a )), ...); cout << endl ; } Usage example int x = 5 ; db ( x ); // [x 5] V < int > v { 1 , 2 , 3 }; db ( v ); // [v 1 2 3]","title":"Debug macro"},{"location":"template/#pragmas","text":"Enables some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them. Pragmas #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\")","title":"Pragmas"}]}