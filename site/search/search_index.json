{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#team-members","title":"Team Members","text":"<ul> <li>vilsu / vilsu</li> <li>cebolinha / edu</li> <li>eyz / eyz</li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>Tiagodfs's Template</li> <li>WeakestTopology's Template</li> <li>KACTL</li> <li>CP-Algorithms</li> <li>AtCoder Problems</li> <li>Dynamic A2OJ</li> <li>Algorithms Live!</li> </ul>"},{"location":"dsu/","title":"Disjoint Set Union","text":""},{"location":"dsu/#implementation","title":"Implementation","text":"<p>Warning</p> <p>The implementation uses indices [0, n-1]</p> DSU<pre><code>struct DSU {\nvector&lt;int&gt; p, s;\nDSU (int n) : p(n, -1), s(n, 1) {};\nint find(int v) {\nif (p[v] == -1) return v;\nreturn p[v] = find(p[v]);\n}\nvoid join(int a, int b) {\na = find(a), b = find(b);\nif (a != b) {\nif (s[a] &lt; s[b]) swap(a, b);\np[b] = a, s[a] += s[b];\n}\n}\n};\n</code></pre> <p>This implementation can be tested on Library Checker - Unionfind. [Submission]</p>"},{"location":"dsu/#problems","title":"Problems","text":"<ul> <li>Codeforces 25D - Roads Not Only in Berland</li> </ul>"},{"location":"flow/","title":"Flow","text":""},{"location":"flow/#dinitz","title":"Dinitz","text":"<p>This is based on the implementation on cp-algorithms. But in my opinion this one is much more organized.</p> Dinitz<pre><code>struct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0;\nEdge (int v, int u, int cap) : v(v), u(u), cap(cap) {}\n};\nvector&lt;Edge&gt; edges;\nvector&lt;vector&lt;int&gt;&gt; adj;\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nvoid add_edge(int v, int u, int cap) {\nedges.emplace_back(v, u, cap);\nadj[v].push_back(edges.size()-1);\nedges.emplace_back(u, v, 0);\nadj[u].push_back(edges.size()-1);\n}\nvector&lt;int&gt; level;\nbool bfs() {\nqueue&lt;int&gt; Q;\nlevel.assign(n, -1);\nlevel[s] = 0;\nQ.push(s);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\nfor (auto eid : adj[v]) {\nauto e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != -1) continue;\nlevel[e.u] = level[v] + 1;\nQ.push(e.u);\n}\n}\nreturn level[t] != -1;\n}\nvector&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (f == 0 || v == t) return f;\nfor (int &amp;cid = ptr[v]; cid &lt; adj[v].size(); cid++) {\nint eid = adj[v][cid];\nauto &amp;e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != level[e.v] + 1) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\nreturn newf;\n}\nreturn 0;\n}\nint flow() {\nint f = 0;\nwhile (bfs()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\nf += newf;\n}\nreturn f;\n}\n};\n</code></pre>"},{"location":"flow/#dinitz-min-cost","title":"Dinitz Min-Cost","text":"<p>The same as above, but allows you to set a cost per flow unit for each edge. This is lightly based on the article on cp-algorithms.</p> <p>It uses SPFA instead of Bellman-Ford since it is usually much faster.</p> Dinitz Min-Cost<pre><code>const int INF = 0x3f3f3f3f3f3f3f3f;\nstruct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0, cost;\nEdge(int v, int u, int cap, int cost) : v(v), u(u), cap(cap), cost(cost) {}\n};\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nV&lt;Edge&gt; edges;\nV&lt;V&lt;int&gt;&gt; adj;\nvoid add_edge(int v, int u, int cap, int cost) {\nedges.eb(v, u, cap, cost);\nadj[v].pb(sz(edges)-1);\nedges.eb(u, v, 0, -cost);\nadj[u].pb(sz(edges)-1);\n}\nV&lt;int&gt; dist;\nbool spfa() {\ndist.assign(n, INF);\nqueue&lt;int&gt; Q;\nV&lt;bool&gt; inqueue(n, false);\ndist[s] = 0;\nQ.push(s);\ninqueue[s] = true;\nV&lt;int&gt; cnt(n);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\ninqueue[v] = false;\nfor (auto eid : adj[v]) {\nauto const&amp; e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.u] &gt; dist[e.v] + e.cost) {\ndist[e.u] = dist[e.v] + e.cost;\nif (!inqueue[e.u]) {\nQ.push(e.u);\ninqueue[e.u] = true;\n}\n}\n}\n}\nreturn dist[t] != INF;\n}\nint cost = 0;\nV&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (v == t || f == 0) return f;\nfor (auto &amp;cid = ptr[v]; cid &lt; sz(adj[v]);) {\nauto eid = adj[v][cid];\nauto &amp;e = edges[eid];\ncid++;\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.v] + e.cost != dist[e.u]) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\ncost += e.cost * newf;\nreturn newf;\n}\nreturn 0;\n}\nint total_flow = 0;\nint flow() {\nwhile (spfa()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\ntotal_flow += newf;\n}\nreturn total_flow;\n}\n};\n</code></pre>"},{"location":"geometry/","title":"Geometry","text":""},{"location":"geometry/#relevant-links","title":"Relevant Links","text":"<ul> <li>Easy geometry using std::complex</li> </ul>"},{"location":"kosaraju/","title":"Kosaraju","text":"<p>Can be used to find strongly connected components.</p> Kosaraju<pre><code>struct Kosaraju {\nconst int n;\nV&lt;V&lt;int&gt;&gt; G, Ginv;\nV&lt;bool&gt; vis;\nV&lt;int&gt; comp;\nstack&lt;int&gt; S;\nexplicit Kosaraju(int n) : n(n), G(n), Ginv(n), comp(n, -1) {}\nauto add_edge(int v, int u) {\nG[v].pb(u);\nGinv[u].pb(v);\n}\nauto dfs(int v) -&gt; void {\nvis[v] = true;\nfor (auto u : G[v]) if (!vis[u]) dfs(u);\nS.push(v);\n}\nauto scc(int v, int c) -&gt; void {\nvis[v] = true; comp[v] = c;\nfor (auto u : Ginv[v]) if (!vis[u]) scc(u, c);\n}\nauto run() {\nvis.assign(n, false);\nloop (i, n) if (!vis[i]) dfs(i);\nvis.assign(n, false);\nint cc = 0;\nwhile (!S.empty()) {\nint v = S.top(); S.pop();\nif (!vis[v]) scc(v, cc++);\n}\n}\n};\n</code></pre>"},{"location":"min_window/","title":"Minimum Window","text":""},{"location":"min_window/#implementation","title":"Implementation","text":"<p>Specify a window <code>W</code> and as you push new elements, it will tell you the smallest within <code>W</code> of the last element.</p> Minimum Window<pre><code>struct MinWindow {\nint W;\ndeque&lt;pair&lt;int, int&gt;&gt; Q;\npublic:\nexplicit MinWindow(int W) : W(W) {}\nvoid push(int idx, int x) {\nwhile (!Q.empty() &amp;&amp; Q.front().ff &lt; idx-W+1) Q.pop_front();\nwhile (!Q.empty() &amp;&amp; Q.back().ss &gt;= x) Q.pop_back();\nQ.pb({idx, x});\n}\nint get() const { return Q.front().ss; }\n};\n</code></pre>"},{"location":"min_window/#problems","title":"Problems","text":"<p>A couple problems where this is useful:</p> <ul> <li>(CF797-F) Mice and Holes</li> <li>(CF372-C) Watching Fireworks is Fun</li> <li>(CF1731-D) Valiant's New Map</li> </ul>"},{"location":"seg/","title":"Segment Tree","text":""},{"location":"seg/#implemention","title":"Implemention","text":"Segment Tree<pre><code>template&lt;typename T&gt;\nclass SegmentTree {\nint n;\nT neutral;\nV&lt;T&gt; t;\nstd::function&lt;T(T,T)&gt; merge;\npublic:\nSegmentTree(int n, T neutral,\nstd::function&lt;T(T,T)&gt; merge) {\nthis-&gt;n = n;\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\nt.assign(2*n, neutral);\n}\nSegmentTree(V&lt;T&gt; &amp;v, T neutral,\nstd::function&lt;T(T,T)&gt; merge) {\nthis-&gt;n = v.size();\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\nt.assign(2*n, neutral);\nloop (i, n) t[i+n] = v[i];\nbuild();\n}\nvoid build() {\nfor (int i=n-1; i&gt;0; i--)\nt[i]=merge(t[2*i],t[2*i+1]);\n}\nT query(int l, int r) {\nT rl = neutral, rr = neutral;\nfor (l+=n, r+=n+1; l&lt;r; l/=2, r/=2) {\nif (l&amp;1) rl = merge(rl, t[l++]);\nif (r&amp;1) rr = merge(t[--r], rr);\n}\nreturn merge(rl, rr);\n}\nvoid update(int p, T val) {\nfor (t[p+=n]=val; p &gt; 1; p /= 2)\nt[p/2] = merge(t[min(p, p^1)], t[max(p, p^1)]);\n}\n};\n</code></pre> Usage example<pre><code>// Lambda macro\n#define L2(res ...) [](auto x, auto y){ return res; }\n// Addition Seg\nSegmentTree&lt;int&gt; seg_add(n, 0, L2(x+y));\n// Maximum Seg\nSegmentTree&lt;int&gt; seg_max(n, -INF, L2(max(x,y)));\n// Minimum and Maximum Seg\nSegmentTree&lt;ii&gt; seg_minmax(n, {INF, -INF}, L2(min(x.ff, y.ff), max(x.ss, y.ss)));\n</code></pre>"},{"location":"template/","title":"Template","text":""},{"location":"template/#full-template","title":"Full Template","text":"Full template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// Template (v1.4.3 - 2023-04-22) (codeforces:cebolinha, atcoder:edu) {{{\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntemplate&lt;class T&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#define int long long\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\ntemplate&lt;class T&gt; using V = vector&lt;T&gt;;\ntemplate&lt;class T&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;\nusing ii = pair&lt;int, int&gt;;\nusing iii = array&lt;int, 3&gt;;\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define eb emplace_back\n#define ff first\n#define ss second\n#define nemo &gt;&lt;&gt;\n#define loop(ii, n) for (int ii = 0; ii &lt; (n); ii++)\n#define cond(c, t, f) ((c) ? (t) : (f))\n#define mem(a, b) memset((a), (b), sizeof(a))\n#define inbounds(x, l, r) ((l) &lt;= (x) &amp;&amp; (x) &lt;= (r))\n#define L1(res...) [&amp;](auto x){ return res; }\n#define L2(res...) [&amp;](auto x, auto y){ return res; }\ntemplate&lt;class T, class U&gt; inline void miq(T&amp; a, U b){ if (a &gt; b) a = b; }\ntemplate&lt;class T, class U&gt; inline void maq(T&amp; a, U b){ if (a &lt; b) a = b; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, U&gt; &amp;p) { return is &gt;&gt; p.ff &gt;&gt; p.ss; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, U&gt; const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; ')'; }\nconst auto EMPTY_STRING = \"\", SEPARATOR = \" \";\ntemplate&lt;class T&gt; auto &amp;operator&gt;&gt;(istream&amp; is, vector&lt;T&gt; &amp;c) { for (auto &amp;x : c) is &gt;&gt; x; return is; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, vector&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, multiset&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, ordered_set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, deque&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, map&lt;K,V&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_map&lt;K,V&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class... A&gt; void in(A &amp;...a) { ((cin &gt;&gt; a), ...); }\ntemplate&lt;class... A&gt; void out(A const&amp;... a) { auto sep = EMPTY_STRING; ((cout &lt;&lt; sep &lt;&lt; a, sep = SEPARATOR), ...); cout &lt;&lt; '\\n'; }\ntemplate&lt;class... A&gt; void print(A const&amp;... a) { ((cout &lt;&lt; a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate&lt;class... A&gt; void db(A const&amp;... a) { ((cout &lt;&lt; (a)), ...); cout &lt;&lt; endl; }\n//}}}\nauto main() -&gt; signed {\nfastio;\n}\n</code></pre>"},{"location":"template/#pragmas","title":"Pragmas","text":"<p>Pragmas enable some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them.</p>"},{"location":"blog/purr/","title":"Purr","text":"<p>This is a really educational greedy solution to an AtCoder problem. It may be obvious to some of you, but given the problem is rated 1835 on AtCoder, which is equivalent to 2100 on Codeforces, I'd say it is a pretty challenging problem.</p> <p>The following is (abc214_e) Packing Under Range Regulations with a very slightly modified statement:</p>"},{"location":"blog/purr/#problem-statement","title":"Problem Statement","text":"<p>There are \\(10^9\\) boxes numbered \\(1, 2, \\ldots, 10^9\\) and \\(N\\) balls numbered \\(1, 2, \\ldots, N\\).</p> <p>Each box can contain at most one ball.</p> <p>Determine whether it is possible to put all \\(N\\) balls in the boxes so that the following condition will be satisfied.</p> <ul> <li>For each integer \\(i\\) from \\(1\\) through \\(N\\), the ball numbered \\(i\\) is in a box numbered between \\(L_i\\) and \\(R_i\\) (inclusive).</li> </ul>"},{"location":"blog/purr/#constraints","title":"Constraints","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\times 10^9\\)</li> </ul>"},{"location":"blog/purr/#how-to-solve-it","title":"How to solve it","text":"<p>I suggest you try your best to solve the problem so you can may get familiar with its challenges.</p>"},{"location":"blog/purr/#my-bad-solution","title":"My bad solution","text":"<p>When I first read this problem I was reminded of Hall's Marriage Theorem, which led to a very convoluted solution involving lazy segment trees and ordered sets. But this isn't the solution we'll discuss, since the problem's editorial outlines a much more elegant solution which I've found useful many times since.</p>"},{"location":"blog/purr/#story","title":"Story","text":"<p>You walk along the boxes, from \\(1\\) to \\(10^9\\). Never turning back. Behind some of the boxes there may be one or more people, each holding a ball, which they want to hand off to you. The person with ball \\(i\\) is behind the box \\(L_i\\). If you meet a person, you need to take the ball they're holding.</p> <p>At any moment you can put any of the balls you're holding inside of the box in front of you. You can even put in the ball the person is behind the box just gave you. But the box only holds a single ball.</p> <p>But there is a problem, each ball is actually a ticking bomb. More specifically, ball \\(i\\) is a bomb that will kill you if you don't put it into a box by the time you're past position \\(R_i\\).</p>"},{"location":"blog/purr/#what-it-means","title":"What it means","text":"<p>I hope it is clear how the story above is equivalent to the initial problem. I like framing the problem like this because it makes it much clearer what you're supposed to do.</p> <p>There's never a point in leaving a box empty if you're holding any bombs. You won't be able to come back to it and get rid of some future bomb anyways. Might as well take some weight off your back. But you do have a choice in this problem: which of the bombs to discard.</p> <p>Now imagine you're at box \\(6\\), and you're holding three bombs which are going to explode at times \\(7\\), \\(9\\) and \\(10\\). You can get rid of a single one of them. Which bomb do you get rid of? If you aren't sure of the answer I really hope you don't find yourself in possession of multiple ticking bombs.</p> <p>You should always get rid of the bomb that is closer to exploding. Sometimes this isn't absolutely necessary, but it would be silly not to. Getting rid of it gives you the best chance of survival. It's easy to see how this would be right intuitively, but I provide a proof for the sake of completeness.</p>"},{"location":"blog/purr/#proof","title":"Proof","text":"<p>Imagine some configuration of bomb choices where you didn't explode. Let's say that at some point you didn't get rid of the bomb closer to exploding \\(X\\), but rather some other bomb \\(Y\\) which would explode later. You only got rid of \\(X\\) some time later.</p> <p>If you switch the positions of bombs \\(X\\) and \\(Y\\) you would still have a valid configuration. \\(X\\) moved backwards in the switch, so it clearly still doesn't explode. \\(Y\\) moved ahead, but it moved to a position where \\(X\\) would have exploded, and by definition \\(Y\\) explodes after than \\(X\\).</p> <p>So now you've got a configuration with less \"inversions\", that is, there are less points where you chose the \"wrong\" bomb. If you keep doing this process, you can transform any valid configuration into the one we would get by our greedy, while keeping it valid. This means that if a solution exists, our greedy is a valid solution.</p>"},{"location":"blog/purr/#implementation","title":"Implementation","text":"<p>Just simulating the situation above will give you an \\(\\mathcal{O}(N\\log N)\\) solution. The \\(\\log\\) comes from sorting the balls in your inventory (with a priority queue for instance).</p> <p>Go through the positions from \\(1\\) to \\(10^9\\) getting any balls you come across and getting rid of them as you can. If any bomb explodes you lose.</p> <p>It is also important that if you don't have any balls in your inventory you skip to the next person that will give you a ball.</p> <p>If you do get stuck, reference the problem's editorial.</p>"},{"location":"blog/purr/#other-problems","title":"Other problems","text":"<p>Here are two problems that can be solved if you're able to reduce them to Purr:</p> <ul> <li>(agc008_d) Kth-K</li> <li>(CF555_b) Case of Fugitive</li> </ul>"},{"location":"editorial/unbdesc2023/","title":"UnBDESC 2023","text":"<p>Link para submeter as quest\u00f5es</p>"},{"location":"editorial/unbdesc2023/#fibonacci-string","title":"Fibonacci String","text":"<p>Podemos pr\u00e9-calcular facilmente quantas letras temos em \\(F_0, F_1, F_2\\dots\\), esse ser\u00e1 o vetor <code>AB</code> abaixo. Tamb\u00e9m guardaremos o tamanho de cada uma dessas palavras em <code>LEN</code>.</p> <p>Queremos saber as quantidades de \\(a\\) e \\(b\\) em \\(\\mathcal{F}[L, R]\\). Podemos fazer isso conseguindo essas quantidades em \\(\\mathcal{F}[0,R]\\) e removendo as quantidades em \\(\\mathcal{F}[0,L-1]\\).</p> <p>Quando pegamos um prefixo de \\(\\mathcal{F}\\), vamos pegar v\u00e1rias strings completas, mais um prefixo de uma palavra que ficou incompleta. Fazemos isso na fun\u00e7\u00e3o <code>ab_count</code>, que adiciona as letras de palavras completas enquanto o total n\u00e3o ultrapassa a quantidade de letras que queremos. No fim, ela chama a fun\u00e7\u00e3o <code>word_prefix</code> que acha a quantidade de cada letra num prefixo dessa palavra incompleta.</p> <p>A fun\u00e7\u00e3o <code>word_prefix</code> tem dois casos base. Se o prefixo que queremos tem tamanho \\(0\\), as quantidades s\u00e3o \\(0\\). Al\u00e9m disso, criamos casos especiais para a primeira e a segunda palavra.</p> <p>O principal fato que deve ser notado \u00e9 que como \\(F_k = F_{k-1} \\oplus F_{k-2}\\), se temos um prefixo de \\(F_k\\) que \u00e9 menor ou igual \u00e0 \\(F_{k-1}\\), ele \u00e9 equivalente \u00e0 um prefixo do mesmo tamanho de \\(F_{k-1}\\). Sen\u00e3o, ele \u00e9 \\(F_{k-1}\\) por completo, mais um prefixo de \\(F_{k-2}\\). Assim, podemos definir <code>word_prefix</code> recursivamente de uma forma simples.</p> <p>Complexidade: \\(\\mathcal{O}(\\log_\\varphi R)\\)? \u00c9 t\u00e3o r\u00e1pido que nem importa</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define int long long\npair&lt;int, int&gt; operator+(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\nreturn {a.first + b.first, a.second + b.second};\n}\nconst int MAXF = 86;\npair&lt;int, int&gt; AB[MAXF];\nint LEN[MAXF];\npair&lt;int, int&gt; word_prefix(int idx, int len) {\nif (len == 0) return {0, 0};\nif (idx == 0 || idx == 1) return AB[idx];\nif (len &lt;= LEN[idx-1]) return word_prefix(idx-1, len);\nreturn AB[idx-1] + word_prefix(idx-2, len-LEN[idx-1]);\n}\npair&lt;int, int&gt; ab_count(int prefix_len) {\nint idx = 0;\nint len = 0;\npair&lt;int, int&gt; ab{0, 0};\nwhile (len + LEN[idx] &lt;= prefix_len) {\nab = ab + AB[idx];\nlen += LEN[idx];\nidx++;\n}\nint left = prefix_len - len;\nreturn ab + word_prefix(idx, left);\n}\nsigned main() {\nAB[0] = {0, 1}; LEN[0] = 1;\nAB[1] = {1, 0}; LEN[1] = 1;\nfor (int i = 2; i &lt; MAXF; i++) {\nAB[i] = AB[i-1] + AB[i-2];\nLEN[i] = LEN[i-1] + LEN[i-2];\n}\nint l, r;\ncin &gt;&gt; l &gt;&gt; r;\nauto [ra, rb] = ab_count(r+1);\nauto [la, lb] = ab_count(l);\ncout &lt;&lt; ra-la &lt;&lt; ' ' &lt;&lt; rb-lb &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#interruptores","title":"Interruptores","text":"<p>Para simplificar o c\u00f3digo, convertemos os valores do vetor de \\((1, 0, -1)\\) para \\((0, 1, 2)\\).</p> <p>Fazemos uma DP que guarda para \\((i, j)\\) o menor custo para obter \\(A_0 \\dots A_i\\) com \\(A_i = j\\). A DP \u00e9 baseada do fato que para obter \\(A_0 \\dots A_i\\), devemos primeiro obter \\(A_0 \\dots A_{i-1}\\) com \\(A_{i-1} = j \\text{ ou } j-1\\) e depois adicionar \\(A_i = j\\). Devemos somar o custo \\(1\\) para mudar o estado do interruptor caso \\(A_i \\neq j\\).</p> <p>Para \\(i=0\\) temos os casos base: \\(D_{(0,0)} = A_0 \\neq 0, D_{(0, 1)} = \\infty, D_{(0, 2)} = \\infty\\).</p> <p>Para \\(i&gt;0\\), temos:</p> \\[ D_{(i, j)} = min \\begin{cases}     D_{(i-1, j)}\\\\     D_{(i-1, j-1)} \\text{ para } j &gt; 0 \\end{cases} + (A_i \\neq j) \\] <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nint n;\nint A[100'000 + 8];\nint DP[100'000 + 8][3];\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\ncin &gt;&gt; n;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nif (A[i] == +1) A[i] = 0;\nelse if (A[i] ==  0) A[i] = 1;\nelse if (A[i] == -1) A[i] = 2;\n}\nDP[0][0] = (A[0] != 0);\nDP[0][1] = DP[0][2] = INF;\nfor (int i = 1; i &lt; n; i++) {\nfor (int j = 0; j &lt; 3; j++) {\nDP[i][j] = DP[i-1][j] + (A[i] != j);\nif (j-1 &gt;= 0) {\nDP[i][j] = min(DP[i][j], DP[i-1][j-1] + (A[i] != j));\n}\n}\n}\ncout &lt;&lt; DP[n-1][2] &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#jovem-aprendiz","title":"Jovem Aprendiz","text":"<p>Essa foi a quest\u00e3o com mais submiss\u00f5es da prova (151, ou 31.0%). Foram 12 RTEs, 35 TLEs, 74 WAs e 30 ACs.</p> <p>Muitos dos WAs foram causados por overflows, que podem ser resolvidos trocando <code>int</code> por <code>long long</code>.</p> <p>Os TLEs foram causados pelo fato da solu\u00e7\u00e3o \"naive\" n\u00e3o ser r\u00e1pida o suficiente. Se o monstro tem muita vida (como \\(10^{18}\\)) e os ataques s\u00e3o muito fracos (como \\(1\\) ou \\(2\\)), \u00e9 necess\u00e1ria uma quantidade enorme de ataques para matar o monstro.</p> <p>Um jeito de resolver isso \u00e9 pr\u00e9-calcular a soma dos danos dos \\(N\\) ataques. Digamos que o monstro tem \\(5000\\) de vida e os \\(N\\) ataques d\u00e3o \\(17\\) de dano no total. Podemos ver que o mago usar\u00e1 um ciclo de todos seus ataques pelo menos \\(\\lfloor5000/17\\rfloor = 294\\) vezes. Depois disso resta \\(2\\) de vida, e podemos ir aplicando os ataques um por um enquanto o monstro n\u00e3o morrer.</p> <p>A quantidade de ataques que vai restar ap\u00f3s retirarmos os ciclos completos \u00e9 sempre menor ou igual \u00e0 \\(N\\), pois a vida que sobra \u00e9 menor que o dano de um ciclo de ataques. Assim o loop que vai aplicando o dano de cada ataque enquanto o monstro estiver vivo n\u00e3o vai rodar mais do que \\(N\\) vezes, sendo r\u00e1pido o suficiente.</p> <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nlong long A[100'000 + 8];\nint main() {\nlong long n, m;\ncin &gt;&gt; n &gt;&gt; m;\nlong long sum = 0;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nsum += A[i];\n}\nlong long ans = (m/sum) * n;\nm %= sum;\nfor (int i = 0; i &lt; n; i++) {\nm -= A[i];\nans++;\nif (m &lt;= 0) break;\n}\ncout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#keyboard","title":"Keyboard","text":"<p>O enunciado n\u00e3o garante que n\u00e3o v\u00e3o ter dois n\u00fameros iguais seguidos na sequ\u00eancia de digita\u00e7\u00e3o. O jeito mais f\u00e1cil de lidar com isso \u00e9 quando for ler a sequ\u00eancia ignorar os n\u00fameros que s\u00e3o iguais ao n\u00famero anterior.</p> <p>Depois disso \u00e9 s\u00f3 fazer uma BFS, onde em vez do estado ser \\((i, j)\\), ele \u00e9 \\((i, j, \\text{done})\\), onde \\(\\text{done}\\) \u00e9 a quantidade de itens da sequ\u00eancia que j\u00e1 foram satisfeitos. O c\u00f3digo abaixo \u00e9 bem auto-explicativo.</p> <p>Complexidade: \\(\\mathcal{O}(N\\cdot M\\cdot Q)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst vector&lt;pair&lt;int, int&gt;&gt; delta{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\nint n, m;\ncin &gt;&gt; n &gt;&gt; m;\nvector grid(n, vector&lt;int&gt;(m));\nfor (int i = 0; i &lt; n; i++)\nfor (int j = 0; j &lt; m; j++)\ncin &gt;&gt; grid[i][j];\nint q; cin &gt;&gt; q;\nvector&lt;int&gt; path;\nfor (int i = 0; i &lt; q; i++) {\nint x; cin &gt;&gt; x;\nif (path.empty() || path.back() != x)\npath.push_back(x);\n}\nq = size(path);\nvector dist(n, vector(m, vector&lt;int&gt;(q+1, -1)));\nqueue&lt;array&lt;int, 4&gt;&gt; Q;\nint first_done = path[0] == grid[0][0];\nQ.push({0, 0, 0, first_done});\nwhile (!Q.empty()) {\nauto [vd, vi, vj, vdone] = Q.front(); Q.pop();\nif (vdone == q) return cout &lt;&lt; vd &lt;&lt; endl, 0;\nfor (auto [di, dj] : delta) {\nint ui = vi + di, uj = vj + dj;\nif (!(0 &lt;= ui &amp;&amp; ui &lt; n)) continue;\nif (!(0 &lt;= uj &amp;&amp; uj &lt; m)) continue;\nint udone = vdone + (grid[ui][uj] == path[vdone]);\nif (dist[ui][uj][udone] == -1) {\ndist[ui][uj][udone] = vd + 1;\nQ.push({vd+1, ui, uj, udone});\n}\n}\n}\n}\n</code></pre>"},{"location":"mathematics/bitmasks/","title":"Bitmasks","text":""},{"location":"mathematics/bitmasks/#number-of-supermasks","title":"Number of supermasks","text":"<p>Given a list of masks, count for each possible mask how many masks it is a submask of.</p> Number of supermasks<pre><code>const int MAXB = 15;\nvector&lt;int&gt; amount[1 &lt;&lt; MAXB];\nfor (int b = MAXB-1; b &gt;= 0; b--) {\nfor (int j = 0; j &lt; 1 &lt;&lt; MAXB; j++) {\nif (j &amp; (1 &lt;&lt; b)) {\namount[j ^ (1 &lt;&lt; b)] += amount[j];\n}\n}\n}\n</code></pre>"},{"location":"mathematics/bitmasks/#problems","title":"Problems","text":"<ul> <li>(CF1523-B) Love-Hate</li> <li>(CF449-D) Jzzhu and Numbers</li> </ul>"},{"location":"mathematics/combinatorics/","title":"Combinatorics","text":""},{"location":"mathematics/combinatorics/#implementation","title":"Implementation","text":"<p>This implementation is based on the one by WeakestTopology, which is available on his Github repository.</p> Combinatorics<pre><code>template &lt;unsigned P&gt;\nstruct Combinatorics {\nvector&lt;Z&lt;P&gt;&gt; fact, ifact;\nexplicit Combinatorics(int N) : fact(N), ifact(N) {\nfact[0] = 1;\nfor (int i = 1; i &lt; N; i++) fact[i] = fact[i-1] * i;\nifact[N-1] = 1 / fact[N-1];\nfor (int i = N-1; i-1 &gt;= 0; i--) ifact[i-1] = ifact[i] * i;\n}\nZ&lt;P&gt; C(int n, int k) const {\nreturn k &lt; 0 || n &lt; k ?  0 : fact[n] * ifact[k] * ifact[n-k];\n}\nZ&lt;P&gt; S(int n, int k) const {\nreturn k == 0 ? n == 0 : C(n + k - 1, k - 1);\n}\n};\n</code></pre>"},{"location":"mathematics/xor_basis/","title":"XOR-Basis","text":""},{"location":"mathematics/xor_basis/#implementation","title":"Implementation","text":"XOR Basis<pre><code>struct Basis {\nvector&lt;int&gt; B;\nint reduce(int x) {\nfor (auto b : B) x = min(x, x^b);\nreturn x;\n}\nvoid insert(int x) {\nint r = reduce(x);\nif (r) B.push_back(r);\n}\n};\n</code></pre>"},{"location":"mathematics/xor_basis/#explanation","title":"Explanation","text":"<p>On USACO Guide you can find a great presentation by Benq, as well as various problems.</p>"},{"location":"mathematics/z_p/","title":"Modular Arithmetic","text":""},{"location":"mathematics/z_p/#implementation","title":"Implementation","text":"<p>This implementation is heavily based on the one by WeakestTopology, which is available on his Github repository.</p> Modular Arithmetic<pre><code>template&lt;unsigned P&gt;\nstruct Z {\nunsigned value;\ntemplate&lt;typename T, typename = enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;&gt;\nconstexpr Z(T a) : value((((long long)a % P) + P) % P) {}\nZ&amp; operator+=(Z rhs) {\nvalue += rhs.value;\nif (value &gt;= P) value -= P;\nreturn *this;\n}\nZ&amp; operator-=(Z rhs) {\nvalue += P - rhs.value;\nif (value &gt;= P) value -= P;\nreturn *this;\n}\nZ&amp; operator*=(Z rhs) {\nvalue = (unsigned long long)value * rhs.value % P;\nreturn *this;\n}\nZ&amp; operator/=(Z rhs) { return *this *= pow(rhs, -1); }\nZ operator+() const { return *this; }\nZ operator-() const { return Z() - *this; }\nbool operator==(Z rhs) const { return value == rhs.value; }\nbool operator!=(Z rhs) const { return value != rhs.value; }\nfriend Z operator+(Z lhs, Z rhs) { return lhs += rhs; }\nfriend Z operator-(Z lhs, Z rhs) { return lhs -= rhs; }\nfriend Z operator*(Z lhs, Z rhs) { return lhs *= rhs; }\nfriend Z operator/(Z lhs, Z rhs) { return lhs /= rhs; }\nfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Z a) { return out &lt;&lt; a.value; }\nfriend istream&amp; operator&gt;&gt;(istream&amp; in, Z&amp; a) {\nlong long x;\nin &gt;&gt; x;\na = Z(x);\nreturn in;\n}\n};\ntemplate&lt;unsigned P&gt;\nZ&lt;P&gt; pow(Z&lt;P&gt; x, long long p) {\nif (x == 0) {\nreturn p == 0 ? 1 : 0;\n}\np %= P -1;\nif (p &lt; 0) p += P-1;\nZ&lt;P&gt; res = 1;\nwhile (p) {\nif (p &amp; 1) {\nres *= x;\n}\nx *= x;\np &gt;&gt;= 1;\n}\nreturn res;\n}\n</code></pre>"},{"location":"meta/checklist/","title":"Checklist","text":""},{"location":"meta/checklist/#thinking-about-solution","title":"Thinking about solution","text":"<ul> <li>Immediately play with the sample cases, you may have understood the problem wrong</li> <li>Pay close attention to the constraints</li> <li>Always consider doing Binary Search on the answer</li> </ul>"},{"location":"meta/checklist/#before-submitting","title":"Before Submitting","text":"<ul> <li>Even if the test cases pass, make sure your code is at least doing something</li> <li>If the test cases are too simple, come up with a couple extra ones</li> <li>Check if constants are big enough</li> <li>Check time and memory limits</li> <li>Submit the right file</li> </ul>"},{"location":"meta/checklist/#general","title":"General","text":"<ul> <li><code>#define int long long</code></li> <li>Fast IO</li> <li>Be very careful when copy pasting, check you've changed everything that needs changing</li> <li>Be wary of special cases, and when you do define one, be very sure you've correctly identified the full extent of their implications</li> </ul>"},{"location":"meta/checklist/#stl","title":"STL","text":"<ul> <li>Don't call .back(), .front(), .top() on empty containers</li> <li>Don't change a container as you iterate through it (Even accessing a map may change it)</li> <li>Always make sure your iterators are valid</li> </ul>"},{"location":"meta/checklist/#graphs","title":"Graphs","text":"<ul> <li>Add edges both ways if the graph is bidirectional</li> </ul>"},{"location":"meta/checklist/#beecrowduva","title":"Beecrowd/UVa \ud83e\udd2e","text":"<ul> <li>Don't put space at the end of output</li> <li>Check if there are multiple testcases</li> </ul>"},{"location":"meta/commands/","title":"Commands","text":""},{"location":"meta/commands/#compiling","title":"Compiling","text":"<p>Sanitizers are very useful. Always use them with <code>-g3</code>, which enables debug information. It makes it so you can instantly know which line is causing your runtime error.</p> <pre><code>g++ -Wall -Wextra -Wconversion -g3 -O3 -fsanitize=address,undefined a.cpp -o a\n</code></pre>"},{"location":"meta/commands/#valgrind","title":"Valgrind","text":"<pre><code>valgrind --tool=cachegrind ./a &lt; a.txt\nkcachegring kcachegrind cachegrind.out.XXXX\n</code></pre>"},{"location":"meta/commands/#hashing","title":"Hashing","text":"<p>Hashes a file, ignoring all whitespace and comments. Use for verifying that code was correctly typed.</p> <pre><code>cpp -dD -P -fpreprocessed | tr -d '[:space:]'| md5sum | cut -c-6\n</code></pre>"},{"location":"meta/gyms/","title":"Gyms","text":""},{"location":"meta/gyms/#2023-05-26","title":"2023-05-26","text":"<ul> <li>Contest: 2020-2021 ACM-ICPC Latin American Regional Programming Contest</li> <li>Location: LINF 1 - UnB</li> <li>Duration: 4h</li> <li>Team: eyz, cebolinha, vilsu</li> <li>Expectation: We should try to solve at least 6 problems but 7 or 8 would be good</li> <li>Result: Solved 8 problems, if we had 2 or 3 extra minutes we would have solved J as well</li> </ul>"},{"location":"meta/gyms/#future-gyms","title":"Future Gyms","text":"<ul> <li>Universal Cup. Stage 4: Ukraine</li> <li>Universal Cup. Stage 9: Qingdao</li> <li>Universal Cup. Stage 14: Ranoa</li> <li>2022 ICPC Southeastern Europe</li> <li>The 2021 ICPC Asia Nanjing</li> </ul>"},{"location":"meta/vedj/","title":"Virtual Every Day June","text":""},{"location":"meta/vedj/#day-1","title":"Day 1","text":"<p>Educational Codeforces Round 134</p> <ul> <li>cebolinha: \\(2176 - 88 = 2088\\)</li> <li>EYZ: \\(1595 - 60 = 1535\\)</li> <li>Vilsu: \\(1778 - (assistindo video do raluca) = ???\\)</li> </ul>"},{"location":"meta/vedj/#day-2","title":"Day 2","text":"<p>Educational Codeforces Round 96</p> <ul> <li>cebolinha: \\(2088 + 121 = 2209\\)</li> </ul>"}]}