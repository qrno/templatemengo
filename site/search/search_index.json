{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#team-members","title":"Team Members","text":"<ul> <li>vilsu / vilsu</li> <li>cebolinha / edu</li> <li>eyz / eyz</li> </ul>"},{"location":"#links","title":"Links","text":""},{"location":"#code-notebooks","title":"Code Notebooks","text":"<ul> <li>Tiagodfs</li> <li>WeakestTopology</li> <li>brunomont</li> <li>NUS</li> <li>KACTL</li> </ul>"},{"location":"#problem-lists","title":"Problem Lists","text":"<ul> <li>AtCoder Problems</li> <li>Codeforces Problems</li> <li>Dynamic A2OJ</li> <li>OI Checklist</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>USACO Guide</li> <li>CP-Algorithms</li> <li>Algorithms Live!</li> </ul>"},{"location":"base/template/","title":"Full Template","text":""},{"location":"base/template/#code","title":"Code","text":"Full template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// Template (v1.5.2 - 2023-10-09) (codeforces:cebolinha, atcoder:edu) {{{\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntemplate&lt;class T&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;;\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n#define int long long\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\ntemplate&lt;class T&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;\nusing ii = pair&lt;int, int&gt;;\nusing iii = array&lt;int, 3&gt;;\n#define V vector\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define sz(c) ((int)size(c))\n#define pb push_back\n#define eb emplace_back\n#define ff first\n#define ss second\n#define nemo &gt;&lt;&gt;\n#define loop(ii, n) for (int ii = 0; ii &lt; (n); ii++)\n#define iloop(ii, l, r) for (int ii = (l); ii &lt;= (r); ii++)\n#define cond(c, t, f) ((c) ? (t) : (f))\n#define mem(a, b) memset((a), (b), sizeof(a))\n#define inbounds(x, l, r) ((l) &lt;= (x) &amp;&amp; (x) &lt;= (r))\n#define L1(res...) [&amp;](auto const&amp; x){ return res; }\n#define L2(res...) [&amp;](auto const&amp; x, auto const&amp; y){ return res; }\ntemplate&lt;class T, class U&gt; inline void chmin(T&amp; a, U b){ if (a &gt; b) a = b; }\ntemplate&lt;class T, class U&gt; inline void chmax(T&amp; a, U b){ if (a &lt; b) a = b; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, U&gt; &amp;p) { return is &gt;&gt; p.ff &gt;&gt; p.ss; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, U&gt; const&amp; p) { return os &lt;&lt; '{' &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '}'; }\nconst auto ES = \"\", SEP = \" \";\ntemplate&lt;class T&gt; auto &amp;operator&gt;&gt;(istream&amp; is, vector&lt;T&gt; &amp;c) { for (auto &amp;x : c) is &gt;&gt; x; return is; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, vector&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, multiset&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, ordered_set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, deque&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, map&lt;K,V&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_map&lt;K,V&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class... A&gt; void in(A &amp;...a) { ((cin &gt;&gt; a), ...); }\ntemplate&lt;class... A&gt; void out(A const&amp;... a) { auto sep = ES; ((cout &lt;&lt; sep &lt;&lt; a, sep = SEP), ...); cout &lt;&lt; '\\n'; }\ntemplate&lt;class... A&gt; void print(A const&amp;... a) { ((cout &lt;&lt; a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate&lt;class... A&gt; void db(A const&amp;... a) { ((cout &lt;&lt; (a)), ...); cout &lt;&lt; endl; }\n//}}}\nauto main() -&gt; signed {\nfastio;\n}\n</code></pre>"},{"location":"base/template/#pragmas","title":"Pragmas","text":"<p>Pragmas enable some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them.</p>"},{"location":"base/template_minimal/","title":"Minimal Template","text":""},{"location":"base/template_minimal/#code","title":"Code","text":"Minimal template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define int long long\nsigned main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\n}\n</code></pre>"},{"location":"data_structures/dsu/","title":"Disjoint Set Union","text":""},{"location":"data_structures/dsu/#implementation","title":"Implementation","text":"<p>Includes union by size and path compression optimizations.</p> Disjoint Set Union<pre><code>//{{{ DSU\nstruct DSU {\nvector&lt;int&gt; P, S;\nexplicit DSU (int N) : P(N, -1), S(N, 1) {};\nint leader(int a) {\nif (P[a] == -1) return a;\nreturn P[a] = leader(P[a]);\n}\nint merge(int a, int b) {\na = leader(a);\nb = leader(b);\nif (a == b) return a;\nif (S[a] &lt; S[b]) swap(a, b);\nP[b] = a;\nS[a] += S[b];\nreturn a;\n}\nint same(int a, int b) {\nreturn leader(a) == leader(b);\n}\n};\n//}}}\n</code></pre> <p>This implementation can be tested on Library Checker - Unionfind [Submission]</p>"},{"location":"data_structures/dsu/#problems","title":"Problems","text":"<ul> <li>Codeforces 25D - Roads Not Only in Berland</li> </ul>"},{"location":"data_structures/fenwick_tree/","title":"Fenwick Tree","text":""},{"location":"data_structures/fenwick_tree/#code","title":"Code","text":"Fenwick Tree<pre><code>//{{{ FenwickTree\nstruct FenwickTree {\nint N;\nvector&lt;int&gt; data;\nFenwickTree(int N) : N(N), data(N) {}\nvoid add(int idx, int delta) {\nfor (; idx &lt; N; idx |= idx+1)\ndata[idx] += delta;\n}\nint sum(int r) {\nint ret = 0;\nfor (; r &gt;= 0; r &amp;= r+1, r--)\nret += data[r];\nreturn ret;\n}\nint sum(int l, int r) {\nreturn sum(r) - sum(l-1);\n}\n};\n//}}}\n</code></pre> <p>Can be tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"data_structures/min_window/","title":"Minimum Window","text":""},{"location":"data_structures/min_window/#implementation","title":"Implementation","text":"<p>Specify a window <code>W</code> and as you push new elements, it will tell you the smallest within <code>W</code> of the last element.</p> Minimum Window<pre><code>// Be careful with case W = 0\nstruct MinWindow {\nint W;\ndeque&lt;pair&lt;int, int&gt;&gt; Q;\npublic:\nexplicit MinWindow(int W) : W(W) {}\nvoid push(int idx, int x) {\nwhile (!Q.empty() &amp;&amp; Q.front().ff &lt; idx-W+1) Q.pop_front();\nwhile (!Q.empty() &amp;&amp; Q.back().ss &gt;= x) Q.pop_back();\nQ.pb({idx, x});\n}\nint get() const { return Q.front().ss; }\n};\n</code></pre>"},{"location":"data_structures/min_window/#problems","title":"Problems","text":"<p>A couple problems where this is useful:</p> <ul> <li>(CF797-F) Mice and Holes</li> <li>(CF372-C) Watching Fireworks is Fun</li> <li>(CF1731-D) Valiant's New Map</li> </ul>"},{"location":"data_structures/seg_p1/","title":"Seg da P1","text":"<p>Warning</p> <p>Indexado em 0. Tamb\u00e9m nem testei se funciona.</p> <p>Warning</p> <p>N\u00e3o s\u00f3 copiem, tentem fazer sozinhos e usem s\u00f3 como refer\u00eancia.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int MAXN = 1e5 + 8;\nint N;\nint T[4*MAXN];\nvoid update(int idx, int x, int id=1, int il=0, int ir=N-1) {\nif (il == ir) { T[id] = x; return; }\nint im = (il+ir)/2;\nif (idx &lt;= im) update(idx, x, 2*id, il, im);\nelse update(idx, x, 2*id+1, im+1, ir);\nT[id] = T[2*id] + T[2*id+1];\n}\nint query(int l, int r, int id=1, int il=0, int ir=N-1) {\nif (r &lt; il || ir &lt; l) return 0;\nif (l &lt;= il &amp;&amp; ir &lt;= r) return T[id];\nint im = (il+ir)/2;\nreturn query(l, r, 2*id, il, im)\n+ query(l, r, 2*id+1, im+1, ir);\n}\nint main() {\n}\n</code></pre>"},{"location":"data_structures/segment_tree/","title":"Segment Tree","text":""},{"location":"data_structures/segment_tree/#code","title":"Code","text":"<p>Node must have a sum operator, as well as a default constructor which must be the monoid's neutral element.</p> Segment Tree<pre><code>//{{{ Segment Tree\ntemplate&lt;typename T&gt;\nclass SegmentTree {\nint N;\nvector&lt;T&gt; data;\npublic:\nexplicit SegmentTree(int N) : N(N), data(2*N) {}\nexplicit SegmentTree(vector&lt;int&gt; const&amp; A) : N(size(A)) {\nfor (int i = 0; i &lt; N; i++) set(i, A[i]);\n}\nvoid set(int p, T const&amp; val) {\nfor (data[p+=N]=val; p /= 2;)\ndata[p] = data[2*p]+data[2*p+1];\n}\nT get(int p) const {\nreturn data[p + N];\n}\nvoid add(int p, T const&amp; val) {\nset(p, get(p)+val);\n}\nT sum(int l, int r)  const {\nT rl = T(), rr = T();\nfor (l+=N, r+=N+1; l&lt;r; l/=2, r/=2) {\nif (l&amp;1) rl = rl+data[l++];\nif (r&amp;1) rr = data[--r]+rr;\n}\nreturn rl+rr;\n}\n};\n//}}}\n</code></pre> <p>Tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"data_structures/segment_tree/#code-simple","title":"Code (Simple)","text":"<p>This segment tree has a simpler interface in some cases, but I heard that <code>std::function</code> has a little bit of overhead. It runs about 15% slower on Yosupo Probably still faster than a recursive segment tree. If you're doing simple operations on integers it is probably better.</p> <p>On the main implementation, you would need to do this for a max segment tree:</p> <pre><code>struct MaxNode {\nint x;\nexplicit MaxNode (int x=-INF) : x(x) {}\nfriend MaxNode operator+(MaxNode a, MaxNode b) {\nreturn MaxNode(max(a.x, b.x));\n}\n};\nSegmentTree&lt;Node&gt; S(N);\n</code></pre> <p>On this one you can do one of the following:</p> <pre><code>SegmentTreeSimple&lt;int&gt; S(N, -INF, [](int x, int y){return max(x, y);});\nSegmentTreeSimple&lt;int&gt; S(N, -INF, L2(max(x,y))); // with the L2 macro\n</code></pre> Segment Tree Simple<pre><code>//{{{ Segment Tree Simple\ntemplate&lt;typename T&gt;\nclass SegmentTreeSimple {\nint N;\nT neutral;\nvector&lt;T&gt; data;\nfunction&lt;T(T,T)&gt; merge;\npublic:\nSegmentTreeSimple(int N, T neutral, function&lt;T(T,T)&gt; merge) {\nthis-&gt;N = N;\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\ndata.assign(2*N, neutral);\n}\nSegmentTreeSimple(vector&lt;T&gt; const&amp; A, T neutral, function&lt;T(T,T)&gt; merge) {\nthis-&gt;N = A.size();\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\ndata.resize(2*N);\nfor (int i = 0; i &lt; N; i++) data[i+N] = A[i];\nfor (int i=N-1; i&gt;0; i--)\ndata[i]=merge(data[2*i],data[2*i+1]);\n}\nvoid set(int p, T const&amp; val) {\nfor (data[p+=N]=val; p /= 2;)\ndata[p] = merge(data[2*p], data[2*p+1]);\n}\nT get(int p) const {\nreturn data[p + N];\n}\nvoid add(int p, T const&amp; val) {\nset(p, get(p)+val);\n}\nT sum(int l, int r) const {\nT rl = neutral, rr = neutral;\nfor (l+=N, r+=N+1; l&lt;r; l/=2, r/=2) {\nif (l&amp;1) rl = merge(rl, data[l++]);\nif (r&amp;1) rr = merge(data[--r], rr);\n}\nreturn merge(rl, rr);\n}\n};\n//}}}\n</code></pre> <p>Tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"geometry/geometry/","title":"Theory","text":"<p>Counter-clockwise</p> <p>In any context, consider angles are measured in counter-clockwise manner.</p>"},{"location":"geometry/geometry/#dot-product","title":"Dot Product","text":""},{"location":"geometry/geometry/#math","title":"Math","text":"<ul> <li> <p>\\((a, b) \\cdot (x, y) = ax + by\\)</p> </li> <li> <p>\\(a \\cdot b = \\lvert a\\rvert \\lvert b\\rvert \\cos(\\theta)\\)</p> </li> </ul>"},{"location":"geometry/geometry/#properties","title":"Properties","text":"<ol> <li>Can be used for checking acuteness or perpendicularity. Zero means perpendicular. Positive means acute, negative means obtuse.</li> <li>Squared length of a vector: \\(a\\cdot a = {\\lvert a \\rvert}^2\\)</li> <li>Length of projection of \\(a\\) onto \\(b\\): \\(\\dfrac{a \\cdot b}{\\lvert b\\rvert}\\)</li> <li>Angle between vectors: \\(\\arccos\\left(\\dfrac{a\\cdot b}{\\lvert a\\rvert \\lvert b \\rvert}\\right)\\)</li> </ol>"},{"location":"geometry/geometry/#extra","title":"Extra","text":"<p>The set of points which have a certain dot product with a given vector is forms a line.</p>"},{"location":"geometry/geometry/#cross-product","title":"Cross Product","text":""},{"location":"geometry/geometry/#math_1","title":"Math","text":"<ul> <li> <p>\\((a, b) \\times (x, y) = ay - bx\\)</p> </li> <li> <p>\\(a \\times b = \\lvert a \\rvert\\lvert b \\rvert\\sin(\\theta)\\)</p> </li> </ul>"},{"location":"geometry/geometry/#properties_1","title":"Properties","text":"<ol> <li> <p>Can be used to check for left, right or collinearity. If \\(a \\times b\\) is zero, the vectors are collienar. Positive means \\(b\\) is to the left of \\(a\\). Negative means \\(b\\) is to the right of \\(a\\).</p> </li> <li> <p>Represents the area of the parallelogram with sides \\(a\\) and \\(b\\). Is pretty much the determinant.</p> </li> <li> <p>\\(a\\times b = -b\\times a\\)</p> </li> <li> <p>\\((a + b)\\times c = a\\times c + b\\times c\\)</p> </li> </ol>"},{"location":"graphs/flow/","title":"Flow","text":""},{"location":"graphs/flow/#dinitz","title":"Dinitz","text":"<p>This is based on the implementation on cp-algorithms. But in my opinion this one is much more organized.</p> Dinitz<pre><code>struct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0;\nEdge (int v, int u, int cap) : v(v), u(u), cap(cap) {}\n};\nvector&lt;Edge&gt; edges;\nvector&lt;vector&lt;int&gt;&gt; adj;\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nvoid add_edge(int v, int u, int cap) {\nedges.emplace_back(v, u, cap);\nadj[v].push_back(edges.size()-1);\nedges.emplace_back(u, v, 0);\nadj[u].push_back(edges.size()-1);\n}\nvector&lt;int&gt; level;\nbool bfs() {\nqueue&lt;int&gt; Q;\nlevel.assign(n, -1);\nlevel[s] = 0;\nQ.push(s);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\nfor (auto eid : adj[v]) {\nauto e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != -1) continue;\nlevel[e.u] = level[v] + 1;\nQ.push(e.u);\n}\n}\nreturn level[t] != -1;\n}\nvector&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (f == 0 || v == t) return f;\nfor (int &amp;cid = ptr[v]; cid &lt; adj[v].size(); cid++) {\nint eid = adj[v][cid];\nauto &amp;e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != level[e.v] + 1) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\nreturn newf;\n}\nreturn 0;\n}\nint flow() {\nint f = 0;\nwhile (bfs()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\nf += newf;\n}\nreturn f;\n}\n};\n</code></pre>"},{"location":"graphs/flow/#dinitz-min-cost","title":"Dinitz Min-Cost","text":"<p>The same as above, but allows you to set a cost per flow unit for each edge. This is lightly based on the article on cp-algorithms.</p> <p>It uses SPFA instead of Bellman-Ford since it is usually much faster.</p> Dinitz Min-Cost<pre><code>const int INF = 0x3f3f3f3f3f3f3f3f;\nstruct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0, cost;\nEdge(int v, int u, int cap, int cost) : v(v), u(u), cap(cap), cost(cost) {}\n};\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nV&lt;Edge&gt; edges;\nV&lt;V&lt;int&gt;&gt; adj;\nvoid add_edge(int v, int u, int cap, int cost) {\nedges.eb(v, u, cap, cost);\nadj[v].pb(sz(edges)-1);\nedges.eb(u, v, 0, -cost);\nadj[u].pb(sz(edges)-1);\n}\nV&lt;int&gt; dist;\nbool spfa() {\ndist.assign(n, INF);\nqueue&lt;int&gt; Q;\nV&lt;bool&gt; inqueue(n, false);\ndist[s] = 0;\nQ.push(s);\ninqueue[s] = true;\nV&lt;int&gt; cnt(n);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\ninqueue[v] = false;\nfor (auto eid : adj[v]) {\nauto const&amp; e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.u] &gt; dist[e.v] + e.cost) {\ndist[e.u] = dist[e.v] + e.cost;\nif (!inqueue[e.u]) {\nQ.push(e.u);\ninqueue[e.u] = true;\n}\n}\n}\n}\nreturn dist[t] != INF;\n}\nint cost = 0;\nV&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (v == t || f == 0) return f;\nfor (auto &amp;cid = ptr[v]; cid &lt; sz(adj[v]);) {\nauto eid = adj[v][cid];\nauto &amp;e = edges[eid];\ncid++;\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.v] + e.cost != dist[e.u]) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\ncost += e.cost * newf;\nreturn newf;\n}\nreturn 0;\n}\nint total_flow = 0;\nint flow() {\nwhile (spfa()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\ntotal_flow += newf;\n}\nreturn total_flow;\n}\n};\n</code></pre>"},{"location":"graphs/kosaraju/","title":"Kosaraju","text":"<p>Can be used to find strongly connected components.</p> Kosaraju<pre><code>struct Kosaraju {\nconst int n;\nV&lt;V&lt;int&gt;&gt; G, Ginv;\nV&lt;bool&gt; vis;\nV&lt;int&gt; comp;\nstack&lt;int&gt; S;\nexplicit Kosaraju(int n) : n(n), G(n), Ginv(n), comp(n, -1) {}\nauto add_edge(int v, int u) {\nG[v].pb(u);\nGinv[u].pb(v);\n}\nauto dfs(int v) -&gt; void {\nvis[v] = true;\nfor (auto u : G[v]) if (!vis[u]) dfs(u);\nS.push(v);\n}\nauto scc(int v, int c) -&gt; void {\nvis[v] = true; comp[v] = c;\nfor (auto u : Ginv[v]) if (!vis[u]) scc(u, c);\n}\nauto run() {\nvis.assign(n, false);\nloop (i, n) if (!vis[i]) dfs(i);\nvis.assign(n, false);\nint cc = 0;\nwhile (!S.empty()) {\nint v = S.top(); S.pop();\nif (!vis[v]) scc(v, cc++);\n}\n}\n};\n</code></pre>"},{"location":"mathematics/bitmasks/","title":"Bitmasks","text":""},{"location":"mathematics/bitmasks/#iterating-through-all-subsmasks","title":"Iterating through all subsmasks","text":"<p>This technique can be found on this article.</p> Iterating through all submasks of m<pre><code>// doesn't go through 0\nfor (int s=m; s; s=(s-1)&amp;m) {}\n// goes through 0\nfor (int s=m;  ; s=(s-1)&amp;m) {\nif (s == 0) break;\n}\n</code></pre>"},{"location":"mathematics/bitmasks/#number-of-supermasks","title":"Number of supermasks","text":"<p>Given a list of masks, count for each possible mask how many masks it is a submask of. This looks a lot like SOS DP?</p> Number of supermasks<pre><code>const int MAXB = 20;\nvector&lt;int&gt; amount(1 &lt;&lt; MAXB);\nfor (int b = MAXB-1; b &gt;= 0; b--) {\nfor (int j = 0; j &lt; 1 &lt;&lt; MAXB; j++) {\nif (j &amp; (1 &lt;&lt; b)) {\namount[j ^ (1 &lt;&lt; b)] += amount[j];\n}\n}\n}\n</code></pre>"},{"location":"mathematics/bitmasks/#problems","title":"Problems","text":"<ul> <li>(CF1523-B) Love-Hate</li> <li>(CF449-D) Jzzhu and Numbers</li> </ul>"},{"location":"mathematics/combinatorics/","title":"Combinatorics","text":""},{"location":"mathematics/combinatorics/#implementation","title":"Implementation","text":"<p>This implementation is based on the one by WeakestTopology, which is available on his Github repository.</p> Combinatorics<pre><code>template &lt;unsigned P&gt;\nstruct Combinatorics {\nvector&lt;Z&lt;P&gt;&gt; fact, ifact;\nexplicit Combinatorics(int N) : fact(N), ifact(N) {\nfact[0] = 1;\nfor (int i = 1; i &lt; N; i++) fact[i] = fact[i-1] * i;\nifact[N-1] = 1 / fact[N-1];\nfor (int i = N-1; i-1 &gt;= 0; i--) ifact[i-1] = ifact[i] * i;\n}\nZ&lt;P&gt; C(int n, int k) const {\nreturn k &lt; 0 || n &lt; k ?  0 : fact[n] * ifact[k] * ifact[n-k];\n}\nZ&lt;P&gt; S(int n, int k) const {\nreturn k == 0 ? n == 0 : C(n + k - 1, k - 1);\n}\n};\n</code></pre>"},{"location":"mathematics/ext_gcd/","title":"Linear Diophantine Equations","text":"<p>If you want to understand everything, read this [cp-algorithms] - Linear Diophantine Equations. I think this code is much better. It's possible to do it iteratively, but that's probably unnecessary.</p>"},{"location":"mathematics/ext_gcd/#extended-gcd","title":"Extended GCD","text":"<p>Given two integers \\(a\\) and \\(b\\), returns their gcd and two coefficients \\(x\\) and \\(y\\) such that \\(ax + by = g\\).</p>"},{"location":"mathematics/ext_gcd/#linear-diophantine-equations_1","title":"Linear Diophantine Equations","text":"<p>Given three integers \\(a\\), \\(b\\), \\(c\\), returns whether it is possible to get \\(x\\) and \\(y\\) such that \\(ax + by = c\\), as well as \\(x\\) and \\(y\\) if possible.</p> Extended GCD<pre><code>tuple&lt;int, int, int&gt; ext_gcd(int a, int b) {\nif (b == 0) return {a, 1, 0};\nauto [g, x, y] = ext_gcd(b, a%b);\nreturn {g, y, x - (a/b) * y};\n}\ntuple&lt;bool, int, int&gt; dio(int a, int b, int c) {\nauto [g, x, y] = ext_gcd(a, b);\nif (c % g) return {false, -1, -1};\nreturn {true, x * (c/g), y * (c/g)};\n}\n</code></pre>"},{"location":"mathematics/floor_sum/","title":"Floor Sum","text":"<p>Returns the sum</p> \\[ \\sum_{i=0}^{n-1} \\Bigl\\lfloor \\frac{a\\times i + b}{m} \\Bigr\\rfloor \\] <p>in \\(O(\\log m)\\) complexity.</p>"},{"location":"mathematics/floor_sum/#code","title":"Code","text":"<p>My implementation was stolen straight from AtCoder Library.</p> Floor Sum<pre><code>//{{{ Floor Sum\nunsigned long long floor_sum_unsigned(unsigned long long n,\nunsigned long long m,\nunsigned long long a,\nunsigned long long b) {\nunsigned long long ans = 0;\nwhile (true) {\nif (a &gt;= m) {\nans += n * (n - 1) / 2 * (a / m);\na %= m;\n}\nif (b &gt;= m) {\nans += n * (b / m);\nb %= m;\n}\nunsigned long long y_max = a * n + b;\nif (y_max &lt; m) break;\n// y_max &lt; m * (n + 1)\n// floor(y_max / m) &lt;= n\nn = (unsigned long long)(y_max / m);\nb = (unsigned long long)(y_max % m);\nswap(m, a);\n}\nreturn ans;\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\nunsigned long long ans = 0;\nif (a &lt; 0) {\nunsigned long long a2 = (a%m+m)%m;\nans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m);\na = a2;\n}\nif (b &lt; 0) {\nunsigned long long b2 = (a%m+m)%m;\nans -= 1ULL * n * ((b2 - b) / m);\nb = b2;\n}\nreturn ans + floor_sum_unsigned(n, m, a, b);\n}\n//}}}\n</code></pre>"},{"location":"mathematics/xor_basis/","title":"XOR-Basis","text":""},{"location":"mathematics/xor_basis/#implementation","title":"Implementation","text":"XOR Basis<pre><code>struct Basis {\nvector&lt;int&gt; B;\nint reduce(int x) {\nfor (auto b : B) x = min(x, x^b);\nreturn x;\n}\nvoid insert(int x) {\nint r = reduce(x);\nif (r) B.push_back(r);\n}\n};\n</code></pre>"},{"location":"mathematics/xor_basis/#explanation","title":"Explanation","text":"<p>On USACO Guide you can find a great presentation by Benq, as well as various problems.</p>"},{"location":"mathematics/z_p/","title":"Modular Arithmetic","text":""},{"location":"mathematics/z_p/#implementation","title":"Implementation","text":"<p>This implementation is heavily based on the one by WeakestTopology, which is available on his Github repository.</p> Modular Arithmetic<pre><code>template &lt;unsigned P&gt;\nstruct Z {\nunsigned value;\nconstexpr Z() : value(0) {}\ntemplate&lt;typename T, typename = enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;&gt;\nconstexpr Z(T a) : value((((long long)a % P) + P) % P) {}\nZ&amp; operator+=(Z rhs) {\nvalue += rhs.value;\nif (value &gt;= P) value -= P;\nreturn *this;\n}\nZ&amp; operator-=(Z rhs) {\nvalue += P - rhs.value;\nif (value &gt;= P) value -= P;\nreturn *this;\n}\nZ&amp; operator*=(Z rhs) {\nvalue = (unsigned long long)value * rhs.value % P;\nreturn *this;\n}\nZ&amp; operator/=(Z rhs) { return *this *= pow(rhs, -1); }\nZ operator+() const { return *this; }\nZ operator-() const { return Z() - *this; }\nbool operator==(Z rhs) const { return value == rhs.value; }\nbool operator!=(Z rhs) const { return value != rhs.value; }\nfriend Z operator+(Z lhs, Z rhs) { return lhs += rhs; }\nfriend Z operator-(Z lhs, Z rhs) { return lhs -= rhs; }\nfriend Z operator*(Z lhs, Z rhs) { return lhs *= rhs; }\nfriend Z operator/(Z lhs, Z rhs) { return lhs /= rhs; }\nfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Z a) { return out &lt;&lt; a.value; }\nfriend istream&amp; operator&gt;&gt;(istream&amp; in, Z&amp; a) {\nlong long x;\nin &gt;&gt; x;\na = Z(x);\nreturn in;\n}\n};\ntemplate&lt;unsigned P&gt;\nZ&lt;P&gt; pow(Z&lt;P&gt; x, long long p) {\nif (x == 0) {\nreturn p == 0 ? 1 : 0;\n}\np %= P -1;\nif (p &lt; 0) p += P-1;\nZ&lt;P&gt; res = 1;\nwhile (p) {\nif (p &amp; 1) {\nres *= x;\n}\nx *= x;\np &gt;&gt;= 1;\n}\nreturn res;\n}\n</code></pre>"},{"location":"meta/checklist/","title":"Checklist","text":""},{"location":"meta/checklist/#thinking-about-solution","title":"Thinking about solution","text":"<ul> <li>Immediately play with the sample cases, you may have understood the problem wrong</li> <li>Pay close attention to the constraints</li> <li>Always consider doing Binary Search on the answer</li> </ul>"},{"location":"meta/checklist/#before-submitting","title":"Before Submitting","text":"<ul> <li>Even if the test cases pass, make sure your code is at least doing something</li> <li>If the test cases are too simple, come up with a couple extra ones</li> <li>Check if constants are big enough</li> <li>Check time and memory limits</li> <li>Submit the right file</li> </ul>"},{"location":"meta/checklist/#general","title":"General","text":"<ul> <li><code>#define int long long</code></li> <li>Fast IO</li> <li>Be very careful when copy pasting, check you've changed everything that needs changing</li> <li>Be wary of special cases, and when you do define one, be very sure you've correctly identified the full extent of their implications</li> </ul>"},{"location":"meta/checklist/#stl","title":"STL","text":"<ul> <li>Don't call .back(), .front(), .top() on empty containers</li> <li>Don't change a container as you iterate through it (Even accessing a map may change it)</li> <li>Always make sure your iterators are valid</li> </ul>"},{"location":"meta/checklist/#graphs","title":"Graphs","text":"<ul> <li>Add edges both ways if the graph is bidirectional</li> </ul>"},{"location":"meta/checklist/#beecrowduva","title":"Beecrowd/UVa \ud83e\udd2e","text":"<ul> <li>Don't put space at the end of output</li> <li>Check if there are multiple testcases</li> </ul>"},{"location":"meta/commands/","title":"Commands","text":""},{"location":"meta/commands/#compiling","title":"Compiling","text":"<p>Sanitizers are very useful. Always use them with <code>-g3</code>, which enables debug information. It makes it so you can instantly know which line is causing your runtime error.</p> <pre><code>g++ -Wall -Wextra -Wconversion -g3 -O3 -fsanitize=address,undefined a.cpp -o a\n</code></pre>"},{"location":"meta/commands/#valgrind","title":"Valgrind","text":"<pre><code>valgrind --tool=cachegrind ./a &lt; a.txt\nkcachegring kcachegrind cachegrind.out.XXXX\n</code></pre>"},{"location":"meta/commands/#hashing","title":"Hashing","text":"<p>Hashes a file, ignoring all whitespace and comments. Use for verifying that code was correctly typed.</p> <pre><code>cpp -dD -P -fpreprocessed | tr -d '[:space:]'| md5sum | cut -c-6\n</code></pre>"},{"location":"meta/gyms/","title":"Gyms","text":""},{"location":"meta/gyms/#2023-05-26","title":"2023-05-26","text":"<ul> <li>Contest: 2020-2021 ACM-ICPC Latin American Regional Programming Contest</li> <li>Location: LINF 1 - UnB</li> <li>Duration: 4h</li> <li>Team: cebolinha, EYZ, Vilsu</li> <li>Expectation: We should try to solve at least 6 problems but 7 or 8 would be good</li> <li>Result: Solved 8 problems, if we had 2 or 3 extra minutes we would have solved J as well</li> </ul>"},{"location":"meta/gyms/#upsolving","title":"Upsolving","text":"<ul> <li> A. Almost Origami</li> <li> G. Game of Slots</li> <li> I. Impenetrable Wall</li> <li> M. May I add a Letter?</li> </ul>"},{"location":"meta/gyms/#2023-06-23","title":"2023-06-23","text":"<ul> <li>Contest: Brazilian ICPC Summer School 2017, Contest 2017-01-31</li> <li>Location: LINF 1 - UnB</li> <li>Duration: 5h (did about 4h)</li> <li>Team: cebolinha, EYZ, Vilsu</li> </ul>"},{"location":"meta/gyms/#upsolving_1","title":"Upsolving","text":"<ul> <li> B. Prefix-function to z-function</li> <li> F. Fibonacci Strings</li> <li> N. Sum and Product</li> </ul>"},{"location":"meta/gyms/#2023-06-30","title":"2023-06-30","text":"<ul> <li>Contest: La Salle-Pui Ching Programming Challenge \u57f9\u6b63\u5587\u6c99\u7de8\u7a0b\u6311\u6230\u8cfd 2021</li> <li>Location: Little Room - CIC</li> <li>Duration 5h (did 4h)</li> <li>Team: cebolinha, EYZ, Vilsu</li> </ul>"},{"location":"meta/gyms/#upsolving_2","title":"Upsolving","text":"<ul> <li> A. Allowance Exhaustion</li> <li> F. Furthest Travel - Compressed Matrix Exponentiation (?)</li> <li> G. Gold Medal Bout - Really annoying implementation problem</li> <li> H. How to Get Rice</li> <li> K. Kario Mart</li> </ul>"},{"location":"meta/gyms/#2023-07-07","title":"2023-07-07","text":"<ul> <li>Contest: 2023-2024 ICPC German Collegiate Programming Contest (GCPC 2023)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha, EYZ, Vilsu</li> <li>Result: solved 9 problems. Unnecessarily wasted a lot of time on B and K.</li> </ul>"},{"location":"meta/gyms/#upsolving_3","title":"Upsolving","text":"<ul> <li> A. Adolescent Architecture</li> <li> H. Highway Combinatorics</li> <li> F. Freestyle Masonry</li> <li> J. Japanese Lottery</li> </ul>"},{"location":"meta/gyms/#2023-07-13","title":"2023-07-13","text":"<ul> <li>Contest: UTPC Contest 09-17-21 Div. 1 (Advanced)</li> <li>Location: Remote</li> <li>Duration: 2h</li> <li>Team: cebolinha</li> <li>Result: Solved 9/11, didn't even read M. Wasted a lot of time on silly coding mistakes on J and L.</li> </ul>"},{"location":"meta/gyms/#upsolving_4","title":"Upsolving","text":"<ul> <li> K. Alloy Factory</li> <li> M. Ominous Chess</li> </ul>"},{"location":"meta/gyms/#2023-07-14","title":"2023-07-14","text":"<ul> <li>Contest: UTPC Contest 03-24-23 Div. 1 (Advanced)</li> <li>Location: Remote</li> <li>Duration: 2h</li> <li>Team: cebolinha, EYZ</li> <li>Result: Solved 6/8. Didn't even read J, tried G for some time. Not bad.</li> </ul>"},{"location":"meta/gyms/#upsolving_5","title":"Upsolving","text":"<ul> <li> G. Path to Pluto</li> <li> J. Rocket Fuel</li> </ul>"},{"location":"meta/gyms/#2023-09-23","title":"2023-09-23","text":"<ul> <li>Contest: 2023 Argentinian Programming Tournament (TAP)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha, EYZ, vilsu</li> <li>Result: Solved 13/14. Pretty great.</li> </ul>"},{"location":"meta/gyms/#upsolving_6","title":"Upsolving","text":"<ul> <li> K. Kitties</li> </ul>"},{"location":"meta/gyms/#2023-10-01","title":"2023-10-01","text":"<ul> <li>Contest: 2017-2018 Northwestern European Regional Contest (NWERC 2017)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha</li> <li>Result: Solved 7/11. Not bad. F is a nice use of RangeSet. G is a nice geometry problem. Wasted too much time on I because of a line I forgot to delete.</li> </ul>"},{"location":"meta/gyms/#upsolving_7","title":"Upsolving","text":"<ul> <li>[  ] A. Ascending Photo</li> <li>[  ] C. Connect The Dots</li> <li>[  ] E. English Restaurant</li> <li>[  ] J. Juggling Troupe</li> </ul>"},{"location":"meta/gyms/#future-gyms","title":"Future Gyms","text":"<ul> <li>Universal Cup. Stage 4: Ukraine</li> <li>Universal Cup. Stage 9: Qingdao</li> <li>Universal Cup. Stage 14: Ranoa</li> <li>2022 ICPC Southeastern Europe</li> <li>The 2021 ICPC Asia Nanjing</li> <li>NWERC 2021</li> <li>NWERC 2020</li> <li>NWERC 2019</li> <li>NWERC 2018</li> </ul>"},{"location":"meta/rttr/","title":"RTTR","text":""},{"location":"meta/rttr/#about","title":"About","text":""},{"location":"meta/rttr/#theory","title":"Theory","text":"<p>Rounds will be held on the Vjudge Group.</p> <p>After doing 100 rounds of these, you will get the Grandmaster on Codeforces. It is 100% guaranteed, trust me.</p> <p>I'll try to do these often and post little hints and solutions afterwards.</p>"},{"location":"meta/rttr/#rttr-1","title":"RTTR #1","text":"<p>Result:</p> <ul> <li> Fib-Tree</li> <li> Are You Fired?</li> <li> DeadLee</li> </ul> <p>Didn't solve the first problem because of a silly implementation mistake. (Granted I did overcomplicated a little).</p> <p>Overall really great problems, highly recommend solving all of them.</p>"},{"location":"meta/rttr/#fib-tree","title":"Fib-Tree","text":"Hint 1 <p>For a given Fibonacci number, there is a single way of decomposing it into smaller Fibonacci numbers.</p> Hint 2 <p>For a given tree of fibonacci size, there are at most two ways of decomposing it into smaller trees of fibonacci size.</p> Hint 2.1 <p>It doesn't matter which of the ways you pick.</p> Solution <ul> <li>Create some function <code>fibtree(v)</code> which will return a bool if the tree that contains v is a Fib-Tree.</li> <li>Root the tree in v and get all the subtree sizes.</li> <li>Iterate through the tree until you find someone with size \\(F_{i-1}\\) or \\(F_{i-2}\\).</li> <li>Remove the edge connecting that vertex to its parent.<ul> <li>This is possible by making G a <code>vector&lt;set&lt;int&gt;&gt;</code></li> </ul> </li> <li>When you get to a subtree of size at most 3, return true.</li> </ul> Thoughts <ul> <li>Really great problem, but it pretty easy to guess the solution without understanding why it works.</li> <li>I ended up using the trees' centroids, which wasn't too bad but unnecessary.</li> <li>Silly implementation mistake, was returning too eagerly in the <code>get_need</code> function.</li> </ul>"},{"location":"meta/rttr/#are-you-fired","title":"Are You Fired?","text":"Hint 1 <p>If a solution with some length works. A solution with double that length also works.</p> Hint 2 <p>That means that there is a solution with length at least \\(N/2+1\\).</p> Hint 3 <p>That makes the case \\(X &gt; 0\\) really easy.</p> Hint 2.1 <p>Just pick N. Check if that works.</p> Solution <ul> <li>We're down to the case \\(X \\leq 0\\) and we know the length is at least \\(N/2+1\\).</li> <li>Document for each position from the first half how long the range starting at it can be.</li> <li>The length must be at least \\(N/2+1\\). As the range grows the sum decreases, so it is a prefix.</li> <li>Therefore we can binary search for that.</li> <li>To check if some length len works overall,   check if all the indices where ranges would be starting can handle ranges that big.</li> </ul> Thoughts <ul> <li>Did this problem pretty quickly.</li> <li>Did the right choice of dividing it into cases and analysing.</li> </ul>"},{"location":"meta/rttr/#deadlee","title":"DeadLee","text":"Hint 1 <p>Work with the concept of having \"enough\" of a given food. Count how many people want each food. You have enough of it if you have more of it than people want.</p> Solution <ul> <li>What can you do if you have enough of some food \\(f\\)?<ul> <li>Give it to everyone who wants it, then remove these people.</li> <li>By \"remove\" I mean put them in the back of the order and make them \"not want\" the rest of the food.</li> <li>You can do that by keeping a <code>vector&lt;set&lt;int&gt;&gt;</code> with the people that want each food.</li> </ul> </li> <li>If by removing people you now have enough of some other food, put that food on the queue and repeat the process.</li> <li>It is kinda like a BFS</li> <li>Implementation for reference</li> </ul> Thoughts <ul> <li>Really nice problem but also quite easy. Not sure why it is rated 2400.</li> <li>Once you create the concept of having \"enough\" of some food the solution flows pretty naturally.</li> </ul>"},{"location":"meta/vedj/","title":"Virtual Every Day June","text":"<p>Rating changes calculated using Codeforces Visualizer.</p> <p>It is kinda silly to calculate Div. 2 rating changes for ratings over 2100, but I don't care.</p>"},{"location":"meta/vedj/#day-1","title":"Day 1","text":"<p>Educational Codeforces Round 134</p> <ul> <li>cebolinha: \\(2176 - 88 = 2088\\)</li> <li>EYZ: \\(1595 - 60 = 1535\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino","title":"Upsolving Quirino","text":"<ul> <li> E - Prefix Function Queries</li> <li> F - Matching Reduction</li> </ul>"},{"location":"meta/vedj/#day-2","title":"Day 2","text":"<p>Educational Codeforces Round 96</p> <ul> <li>cebolinha: \\(2088 + 121 = 2209\\)</li> <li>EYZ: \\(1535 + 20 = 1555\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_1","title":"Upsolving Quirino","text":"<ul> <li> G - Yet Another DAG Problem</li> </ul>"},{"location":"meta/vedj/#day-3","title":"Day 3","text":"<p>No virtual required since there was AtCoder, Codeforces and Mineira Marathon.</p>"},{"location":"meta/vedj/#upsolving-quirino_2","title":"Upsolving Quirino","text":"<ul> <li> L - Bacon e a \u00c1rvore M\u00e1gica</li> <li> N - Trapa\u00e7a na Pastelaria</li> </ul>"},{"location":"meta/vedj/#day-4","title":"Day 4","text":"<p>Educational Codeforces Round 144</p> <ul> <li>cebolinha: \\(2209 + 37 = 2246\\)</li> <li>EYZ: \\(1555 - 58 = 1497\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_3","title":"Upsolving Quirino","text":"<ul> <li> E - Colored Subgraphs</li> <li> F - Strange Triples</li> </ul>"},{"location":"meta/vedj/#day-5","title":"Day 5","text":"<p>Educational Codeforces Round 148</p> <ul> <li>cebolinha: \\(2246 + 87 = 2333\\)</li> <li>EYZ: \\(1497 - 19 = 1478\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_4","title":"Upsolving Quirino","text":"<ul> <li> F - Zombies</li> </ul>"},{"location":"meta/winter/","title":"Winter Training \u2603\ufe0f","text":""},{"location":"meta/winter/#plans","title":"Plans","text":""},{"location":"meta/winter/#2023-08-15","title":"2023-08-15","text":"<ul> <li>CerealCodes contest in the afternoon.<ul> <li>Disastrous performance</li> <li>Solved two questions, wasted a lot of time on silly stuff</li> <li>Probably could solve C as well. On a very good day even D and E.</li> </ul> </li> <li>edu's Yellow Challenge #8 at night.<ul> <li>Pretty nice problems. One of them was on a Gym so I got it for free.</li> </ul> </li> <li>Upsolve ST and TS Palindrome from edu's Cyan Challenge! #1<ul> <li>Not too bad after all :P</li> </ul> </li> </ul>"},{"location":"meta/winter/#2023-08-16","title":"2023-08-16","text":"<ul> <li>RTTR #2 in the morning.</li> <li>A single AtCoder yellow.</li> <li>UNICAMP Selection Contest 2023 in the afternoon.</li> </ul>"},{"location":"meta/winter/#assorted-problems","title":"Assorted Problems","text":"<ul> <li> Prefix Function Queries</li> <li> Anthem of Berland</li> <li> Bottle Arrangements</li> </ul>"},{"location":"meta/winter/#tree-isomorphism-saga","title":"Tree Isomorphism Saga","text":"<ul> <li> Tree Isomorphism I</li> <li> Regular Forestation</li> <li> Generator Tree</li> <li> Favorite Tree</li> </ul>"},{"location":"meta/winter/#dsu-on-trees-saga","title":"DSU on Trees Saga","text":"<ul> <li> Blood Cousins Return</li> <li> Tree-String Problem</li> <li> Dominant Indices</li> <li> Digit Tree</li> <li> Arpa\u2019s letter-marked tree and Mehrdad\u2019s Dokhtar-kosh paths</li> </ul>"},{"location":"meta/winter/#ponder","title":"Ponder","text":"<ul> <li>Why are the at most two centroids?</li> </ul>"},{"location":"meta/blog/purr/","title":"Purr","text":"<p>Available on Codeforces. Pretty simple technique but found it useful a couple times.</p>"},{"location":"meta/blog/purr/#purr-packing-under-range-regulations","title":"Purr =^..^= Packing Under Range Regulations","text":"<p>This is a simple and educational greedy solution to an AtCoder problem.</p> <p>The following is (abc214_e) Packing Under Range Regulations: (slightly modified)</p>"},{"location":"meta/blog/purr/#problem-statement","title":"Problem Statement","text":"<p>There are \\(10^9\\) boxes numbered \\(1, 2, \\ldots, 10^9\\) and \\(N\\) balls numbered \\(1, 2, \\ldots, N\\).</p> <p>Each box can contain at most one ball.</p> <p>Determine whether it is possible to put all \\(N\\) balls in the boxes so that the following condition will be satisfied.</p> <ul> <li>For each integer \\(i\\) from \\(1\\) through \\(N\\), the ball numbered \\(i\\) is in a box numbered between \\(L_i\\) and \\(R_i\\) (inclusive).</li> </ul>"},{"location":"meta/blog/purr/#constraints","title":"Constraints","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\times 10^9\\)</li> </ul>"},{"location":"meta/blog/purr/#how-to-solve-it","title":"How to solve it","text":"<p>I suggest you try your best to solve the problem before continuining.</p>"},{"location":"meta/blog/purr/#my-initial-solution","title":"My initial solution","text":"<p>Initially, I tried a more complicated solution based on Hall's Marriage Theorem. However, the problem's editorial outlines a much more elegant solution that we will discuss.</p>"},{"location":"meta/blog/purr/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>Imagine you're walking along the boxes from \\(1\\) to \\(10^9\\) without turning back. Some of the boxes may have people behind them, each holding a ball to give you. The person with ball \\(i\\) is behind box \\(L_i\\). Whenever you encounter a person, you take the ball they're holding.</p> <p>At any moment you can place any ball you're holding into the box in front of you, including the one just given to you. However, each box can only hold one ball.</p> <p>But there's a twist: each ball is actually a ticking bomb. Ball \\(i\\) is a bomb that will explode and kill you if you don't put it into a box before passing position \\(R_i\\).</p>"},{"location":"meta/blog/purr/#understanding-the-greedy","title":"Understanding the Greedy","text":"<p>The story above is equivalent to the initial problem statement, but presenting it like this helps make the greedy solution more intuitive.</p> <p>There's never a point in leaving a box empty if you're holding any bombs. You won't be able to come back to it later and leave a bomb there, so you might as well take some weight off your back right now. However, you still have a choice to make: which of the bombs should you discard?</p> <p>For example, imagine you're holding three bombs that will explode at times \\(7\\), \\(8\\), and \\(10\\). You can discard a single bomb. Which one should you choose?</p> <p>The correct approach is to always get rid of the bomb closest to exploding. Although this may not be strictly necessary, there's no reason not to do it. It's intuitive to see how this is correct, but let's provide a proof for completeness:</p>"},{"location":"meta/blog/purr/#proof","title":"Proof","text":"<p>Consider a configuration of bomb choices where no bombs explode. Let's say that at some point, instead of discarding the bomb closer to exploding, denoted as \\(X\\), you discard some other bomb \\(Y\\) that would explode later. You only discard \\(X\\) at a later time.</p> <p>If we switch the positions of bombs \\(X\\) and \\(Y\\), we would still have a valid configuration. \\(X\\) would be discarded earlier than before, so it clearly still wouldn't explode. \\(Y\\) would be discarded later, but it would be discarded in position where \\(X\\) still wouldn't have exploded, and \\(X\\) explodes earlier than \\(Y\\).</p> <p>With this switch, we obtain a configuration with less \"inversions\", meaning there are fewer positions where we chose the \"wrong\" bomb. By repeating this process, we can transform any valid configuration into the one we would get using our greedy approach, without ever making it invalid. Therefore, if a solution exists, our greedy approach is a valid solution.</p>"},{"location":"meta/blog/purr/#implementation","title":"Implementation","text":"<p>The implementation consists of simulating the situation described above, resulting in an \\(\\mathcal{O}(N\\log N)\\) solution. The \\(\\log N\\) factor comes from sorting the balls in our inventory, for example, using a priority queue.</p> <p>We start from position \\(1\\) and iterate through the positions up to \\(10^9\\), taking any balls we encounter and discarding them as possible. Always picking the bomb closer to exploding. If any bomb explodes, there's no solution.</p> <p>It is important to note that if our inventory is empty, we should skip to the next box where you'll be given a ball.</p> <p>If you get stuck, refer to the problem's editorial, where a nice implementation can be found.</p>"},{"location":"meta/blog/purr/#other-problems","title":"Other problems","text":"<p>Here are two problems that can be solved if you're able to reduce them to Purr:</p> <ul> <li>(agc008_d) Kth-K</li> <li>(CF555_b) Case of Fugitive</li> </ul> <p>Curiously, a few days after I wrote this blog, this technique showed up in an AtCoder Beginner Contest:</p> <ul> <li>(abc304_h) Constrained Topological Sort</li> </ul>"},{"location":"meta/editorial/unbdesc2023/","title":"UnBDESC 2023","text":"<p>Link para submeter as quest\u00f5es</p>"},{"location":"meta/editorial/unbdesc2023/#fibonacci-string","title":"Fibonacci String","text":"<p>Podemos pr\u00e9-calcular facilmente quantas letras temos em \\(F_0, F_1, F_2\\dots\\), esse ser\u00e1 o vetor <code>AB</code> abaixo. Tamb\u00e9m guardaremos o tamanho de cada uma dessas palavras em <code>LEN</code>.</p> <p>Queremos saber as quantidades de \\(a\\) e \\(b\\) em \\(\\mathcal{F}[L, R]\\). Podemos fazer isso conseguindo essas quantidades em \\(\\mathcal{F}[0,R]\\) e removendo as quantidades em \\(\\mathcal{F}[0,L-1]\\).</p> <p>Quando pegamos um prefixo de \\(\\mathcal{F}\\), vamos pegar v\u00e1rias strings completas, mais um prefixo de uma palavra que ficou incompleta. Fazemos isso na fun\u00e7\u00e3o <code>ab_count</code>, que adiciona as letras de palavras completas enquanto o total n\u00e3o ultrapassa a quantidade de letras que queremos. No fim, ela chama a fun\u00e7\u00e3o <code>word_prefix</code> que acha a quantidade de cada letra num prefixo dessa palavra incompleta.</p> <p>A fun\u00e7\u00e3o <code>word_prefix</code> tem dois casos base. Se o prefixo que queremos tem tamanho \\(0\\), as quantidades s\u00e3o \\(0\\). Al\u00e9m disso, criamos casos especiais para a primeira e a segunda palavra.</p> <p>O principal fato que deve ser notado \u00e9 que como \\(F_k = F_{k-1} \\oplus F_{k-2}\\), se temos um prefixo de \\(F_k\\) que \u00e9 menor ou igual \u00e0 \\(F_{k-1}\\), ele \u00e9 equivalente \u00e0 um prefixo do mesmo tamanho de \\(F_{k-1}\\). Sen\u00e3o, ele \u00e9 \\(F_{k-1}\\) por completo, mais um prefixo de \\(F_{k-2}\\). Assim, podemos definir <code>word_prefix</code> recursivamente de uma forma simples.</p> <p>Complexidade: \\(\\mathcal{O}(\\log_\\varphi R)\\)? \u00c9 t\u00e3o r\u00e1pido que nem importa</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define int long long\npair&lt;int, int&gt; operator+(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\nreturn {a.first + b.first, a.second + b.second};\n}\nconst int MAXF = 86;\npair&lt;int, int&gt; AB[MAXF];\nint LEN[MAXF];\npair&lt;int, int&gt; word_prefix(int idx, int len) {\nif (len == 0) return {0, 0};\nif (idx == 0 || idx == 1) return AB[idx];\nif (len &lt;= LEN[idx-1]) return word_prefix(idx-1, len);\nreturn AB[idx-1] + word_prefix(idx-2, len-LEN[idx-1]);\n}\npair&lt;int, int&gt; ab_count(int prefix_len) {\nint idx = 0;\nint len = 0;\npair&lt;int, int&gt; ab{0, 0};\nwhile (len + LEN[idx] &lt;= prefix_len) {\nab = ab + AB[idx];\nlen += LEN[idx];\nidx++;\n}\nint left = prefix_len - len;\nreturn ab + word_prefix(idx, left);\n}\nsigned main() {\nAB[0] = {0, 1}; LEN[0] = 1;\nAB[1] = {1, 0}; LEN[1] = 1;\nfor (int i = 2; i &lt; MAXF; i++) {\nAB[i] = AB[i-1] + AB[i-2];\nLEN[i] = LEN[i-1] + LEN[i-2];\n}\nint l, r;\ncin &gt;&gt; l &gt;&gt; r;\nauto [ra, rb] = ab_count(r+1);\nauto [la, lb] = ab_count(l);\ncout &lt;&lt; ra-la &lt;&lt; ' ' &lt;&lt; rb-lb &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#interruptores","title":"Interruptores","text":"<p>Para simplificar o c\u00f3digo, convertemos os valores do vetor de \\((1, 0, -1)\\) para \\((0, 1, 2)\\).</p> <p>Fazemos uma DP que guarda para \\((i, j)\\) o menor custo para obter \\(A_0 \\dots A_i\\) com \\(A_i = j\\). A DP \u00e9 baseada do fato que para obter \\(A_0 \\dots A_i\\), devemos primeiro obter \\(A_0 \\dots A_{i-1}\\) com \\(A_{i-1} = j \\text{ ou } j-1\\) e depois adicionar \\(A_i = j\\). Devemos somar o custo \\(1\\) para mudar o estado do interruptor caso \\(A_i \\neq j\\).</p> <p>Para \\(i=0\\) temos os casos base: \\(D_{(0,0)} = A_0 \\neq 0, D_{(0, 1)} = \\infty, D_{(0, 2)} = \\infty\\).</p> <p>Para \\(i&gt;0\\), temos:</p> \\[ D_{(i, j)} = min \\begin{cases}     D_{(i-1, j)}\\\\     D_{(i-1, j-1)} \\text{ para } j &gt; 0 \\end{cases} + (A_i \\neq j) \\] <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nint n;\nint A[100'000 + 8];\nint DP[100'000 + 8][3];\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\ncin &gt;&gt; n;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nif (A[i] == +1) A[i] = 0;\nelse if (A[i] ==  0) A[i] = 1;\nelse if (A[i] == -1) A[i] = 2;\n}\nDP[0][0] = (A[0] != 0);\nDP[0][1] = DP[0][2] = INF;\nfor (int i = 1; i &lt; n; i++) {\nfor (int j = 0; j &lt; 3; j++) {\nDP[i][j] = DP[i-1][j] + (A[i] != j);\nif (j-1 &gt;= 0) {\nDP[i][j] = min(DP[i][j], DP[i-1][j-1] + (A[i] != j));\n}\n}\n}\ncout &lt;&lt; DP[n-1][2] &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#jovem-aprendiz","title":"Jovem Aprendiz","text":"<p>Essa foi a quest\u00e3o com mais submiss\u00f5es da prova (151, ou 31.0%). Foram 12 RTEs, 35 TLEs, 74 WAs e 30 ACs.</p> <p>Muitos dos WAs foram causados por overflows, que podem ser resolvidos trocando <code>int</code> por <code>long long</code>.</p> <p>Os TLEs foram causados pelo fato da solu\u00e7\u00e3o \"naive\" n\u00e3o ser r\u00e1pida o suficiente. Se o monstro tem muita vida (como \\(10^{18}\\)) e os ataques s\u00e3o muito fracos (como \\(1\\) ou \\(2\\)), \u00e9 necess\u00e1ria uma quantidade enorme de ataques para matar o monstro.</p> <p>Um jeito de resolver isso \u00e9 pr\u00e9-calcular a soma dos danos dos \\(N\\) ataques. Digamos que o monstro tem \\(5000\\) de vida e os \\(N\\) ataques d\u00e3o \\(17\\) de dano no total. Podemos ver que o mago usar\u00e1 um ciclo de todos seus ataques pelo menos \\(\\lfloor5000/17\\rfloor = 294\\) vezes. Depois disso resta \\(2\\) de vida, e podemos ir aplicando os ataques um por um enquanto o monstro n\u00e3o morrer.</p> <p>A quantidade de ataques que vai restar ap\u00f3s retirarmos os ciclos completos \u00e9 sempre menor ou igual \u00e0 \\(N\\), pois a vida que sobra \u00e9 menor que o dano de um ciclo de ataques. Assim o loop que vai aplicando o dano de cada ataque enquanto o monstro estiver vivo n\u00e3o vai rodar mais do que \\(N\\) vezes, sendo r\u00e1pido o suficiente.</p> <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nlong long A[100'000 + 8];\nint main() {\nlong long n, m;\ncin &gt;&gt; n &gt;&gt; m;\nlong long sum = 0;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nsum += A[i];\n}\nlong long ans = (m/sum) * n;\nm %= sum;\nfor (int i = 0; i &lt; n; i++) {\nm -= A[i];\nans++;\nif (m &lt;= 0) break;\n}\ncout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#keyboard","title":"Keyboard","text":"<p>O enunciado n\u00e3o garante que n\u00e3o v\u00e3o ter dois n\u00fameros iguais seguidos na sequ\u00eancia de digita\u00e7\u00e3o. O jeito mais f\u00e1cil de lidar com isso \u00e9 quando for ler a sequ\u00eancia ignorar os n\u00fameros que s\u00e3o iguais ao n\u00famero anterior.</p> <p>Depois disso \u00e9 s\u00f3 fazer uma BFS, onde em vez do estado ser \\((i, j)\\), ele \u00e9 \\((i, j, \\text{done})\\), onde \\(\\text{done}\\) \u00e9 a quantidade de itens da sequ\u00eancia que j\u00e1 foram satisfeitos. O c\u00f3digo abaixo \u00e9 bem auto-explicativo.</p> <p>Complexidade: \\(\\mathcal{O}(N\\cdot M\\cdot Q)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst vector&lt;pair&lt;int, int&gt;&gt; delta{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\nint n, m;\ncin &gt;&gt; n &gt;&gt; m;\nvector grid(n, vector&lt;int&gt;(m));\nfor (int i = 0; i &lt; n; i++)\nfor (int j = 0; j &lt; m; j++)\ncin &gt;&gt; grid[i][j];\nint q; cin &gt;&gt; q;\nvector&lt;int&gt; path;\nfor (int i = 0; i &lt; q; i++) {\nint x; cin &gt;&gt; x;\nif (path.empty() || path.back() != x)\npath.push_back(x);\n}\nq = size(path);\nvector dist(n, vector(m, vector&lt;int&gt;(q+1, -1)));\nqueue&lt;array&lt;int, 4&gt;&gt; Q;\nint first_done = path[0] == grid[0][0];\nQ.push({0, 0, 0, first_done});\nwhile (!Q.empty()) {\nauto [vd, vi, vj, vdone] = Q.front(); Q.pop();\nif (vdone == q) return cout &lt;&lt; vd &lt;&lt; endl, 0;\nfor (auto [di, dj] : delta) {\nint ui = vi + di, uj = vj + dj;\nif (!(0 &lt;= ui &amp;&amp; ui &lt; n)) continue;\nif (!(0 &lt;= uj &amp;&amp; uj &lt; m)) continue;\nint udone = vdone + (grid[ui][uj] == path[vdone]);\nif (dist[ui][uj][udone] == -1) {\ndist[ui][uj][udone] = vd + 1;\nQ.push({vd+1, ui, uj, udone});\n}\n}\n}\n}\n</code></pre>"},{"location":"strings/trie/","title":"Trie","text":""},{"location":"strings/trie/#implamentation","title":"Implamentation","text":"Trie<pre><code>struct Trie {\nconst int MALPHA = 26;\nvector&lt;vector&lt;int&gt;&gt; trie{vector&lt;int&gt;(MALPHA, -1)};\nvector&lt;int&gt; word_cnt{0};\nint add_node() {\ntrie.push_back(vector&lt;int&gt;(MALPHA, -1));\nword_cnt.push_back(0);\nreturn size(trie)-1;\n}\nvoid insert(string const&amp; s) {\nint cur = 0;\nfor (auto c : s) {\nif (trie[cur][c-'a'] == -1)\ntrie[cur][c-'a'] = add_node();\ncur = trie[cur][c-'a'];\n}\nword_cnt[cur]++;\n}\nint count(string const&amp; s) {\nint cur = 0;\nfor (auto c : s) {\nif (trie[cur][c-'a'] == -1)\nreturn false;\ncur = trie[cur][c-'a'];\n}\nreturn word_cnt[cur];\n}\n};\n</code></pre>"},{"location":"strings/trie/#problems","title":"Problems","text":"<ul> <li>(CF456-D) A Lot of Games</li> </ul>"}]}