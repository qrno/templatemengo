{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#team-members","title":"Team Members","text":"<ul> <li>vilsu / vilsu</li> <li>cebolinha / edu</li> <li>eyz / eyz</li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>Tiagodfs's Template</li> <li>CP-Algorithms</li> <li>AtCoder Problems</li> <li>Dynamic A2OJ</li> <li>Algorithms Live!</li> </ul>"},{"location":"checklist/","title":"Checklist","text":""},{"location":"checklist/#general","title":"General","text":"<ul> <li><code>#define int long long</code></li> <li>Fast IO</li> <li>Constants are big enough</li> <li>Be very careful when copy pasting</li> </ul>"},{"location":"checklist/#stl","title":"STL","text":"<ul> <li>Don't call .back(), .front(), .top() on empty containers</li> </ul>"},{"location":"checklist/#solution","title":"Solution","text":"<ul> <li>Binary Search on Answer</li> </ul>"},{"location":"checklist/#graphs","title":"Graphs","text":"<ul> <li>Add edges both ways</li> <li>m edges</li> </ul>"},{"location":"checklist/#segment-tree","title":"Segment Tree","text":"<ul> <li>Assign value on update</li> <li>Don't assign value on query</li> <li>Pushing at the start of updates and queries (on Lazy Segment Trees)</li> </ul>"},{"location":"checklist/#trie","title":"Trie","text":"<ul> <li>String passed as <code>const&amp;</code></li> </ul>"},{"location":"compiling/","title":"Compiling","text":"Compiling a.cpp into a<pre><code>g++ -Wall -Wextra -Wconversion -g3 -O3 -fsanitize=address,undefined a.cpp -o a\n</code></pre> Recording execution with valgrind<pre><code>valgrind --tool=cachegrind ./a &lt; a.txt\n</code></pre>"},{"location":"dsu/","title":"Disjoint Set Union","text":""},{"location":"dsu/#implementation","title":"Implementation","text":"<p>Warning</p> <p>The implementation uses indices [0, n-1]</p> DSU<pre><code>struct DSU {\nvector&lt;int&gt; p, s;\nDSU (int n) : p(n, -1), s(n, 1) {};\nint find(int v) {\nif (p[v] == -1) return v;\nreturn p[v] = find(p[v]);\n}\nvoid join(int a, int b) {\na = find(a), b = find(b);\nif (a != b) {\nif (s[a] &lt; s[b]) swap(a, b);\np[b] = a, s[a] += s[b];\n}\n}\n};\n</code></pre> <p>This implementation can be tested on Library Checker - Unionfind. [Submission]</p>"},{"location":"dsu/#problems","title":"Problems","text":"<ul> <li>Codeforces 25D - Roads Not Only in Berland</li> </ul>"},{"location":"flow/","title":"Flow","text":""},{"location":"flow/#dinitz","title":"Dinitz","text":"Dinitz<pre><code>struct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0;\nEdge (int v, int u, int cap) : v(v), u(u), cap(cap) {}\n};\nvector&lt;Edge&gt; edges;\nvector&lt;vector&lt;int&gt;&gt; adj;\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nvoid add_edge(int v, int u, int cap) {\nedges.emplace_back(v, u, cap);\nadj[v].push_back(edges.size()-1);\nedges.emplace_back(u, v, 0);\nadj[u].push_back(edges.size()-1);\n}\nvector&lt;int&gt; level;\nbool bfs() {\nqueue&lt;int&gt; Q;\nlevel.assign(n, -1);\nlevel[s] = 0;\nQ.push(s);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\nfor (auto eid : adj[v]) {\nauto e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != -1) continue;\nlevel[e.u] = level[v] + 1;\nQ.push(e.u);\n}\n}\nreturn level[t] != -1;\n}\nvector&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (f == 0 || v == t) return f;\nfor (int &amp;cid = ptr[v]; cid &lt; adj[v].size(); cid++) {\nint eid = adj[v][cid];\nauto &amp;e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (level[e.u] != level[e.v] + 1) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\nreturn newf;\n}\nreturn 0;\n}\nint flow() {\nint f = 0;\nwhile (bfs()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\nf += newf;\n}\nreturn f;\n}\n};\n</code></pre> Dinitz Min-Cost<pre><code>const int INF = 0x3f3f3f3f3f3f3f3f;\nstruct Dinitz {\nstruct Edge {\nint v, u, cap, flow=0, cost;\nEdge(int v, int u, int cap, int cost) : v(v), u(u), cap(cap), cost(cost) {}\n};\nint n, s, t;\nDinitz(int n, int s, int t) : n(n), s(s), t(t) {\nadj.resize(n);\n}\nV&lt;Edge&gt; edges;\nV&lt;V&lt;int&gt;&gt; adj;\nvoid add_edge(int v, int u, int cap, int cost) {\nedges.eb(v, u, cap, cost);\nadj[v].pb(sz(edges)-1);\nedges.eb(u, v, 0, -cost);\nadj[u].pb(sz(edges)-1);\n}\nV&lt;int&gt; dist;\nbool spfa() {\ndist.assign(n, INF);\nqueue&lt;int&gt; Q;\nV&lt;bool&gt; inqueue(n, false);\ndist[s] = 0;\nQ.push(s);\ninqueue[s] = true;\nV&lt;int&gt; cnt(n);\nwhile (!Q.empty()) {\nint v = Q.front(); Q.pop();\ninqueue[v] = false;\nfor (auto eid : adj[v]) {\nauto const&amp; e = edges[eid];\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.u] &gt; dist[e.v] + e.cost) {\ndist[e.u] = dist[e.v] + e.cost;\nif (!inqueue[e.u]) {\nQ.push(e.u);\ninqueue[e.u] = true;\n}\n}\n}\n}\nreturn dist[t] != INF;\n}\nint cost = 0;\nV&lt;int&gt; ptr;\nint dfs(int v, int f) {\nif (v == t || f == 0) return f;\nfor (auto &amp;cid = ptr[v]; cid &lt; sz(adj[v]);) {\nauto eid = adj[v][cid];\nauto &amp;e = edges[eid];\ncid++;\nif (e.cap - e.flow &lt;= 0) continue;\nif (dist[e.v] + e.cost != dist[e.u]) continue;\nint newf = dfs(e.u, min(f, e.cap-e.flow));\nif (newf == 0) continue;\ne.flow += newf;\nedges[eid^1].flow -= newf;\ncost += e.cost * newf;\nreturn newf;\n}\nreturn 0;\n}\nint total_flow = 0;\nint flow() {\nwhile (spfa()) {\nptr.assign(n, 0);\nwhile (int newf = dfs(s, INF))\ntotal_flow += newf;\n}\nreturn total_flow;\n}\n};\n</code></pre>"},{"location":"geometry/","title":"Geometry","text":""},{"location":"geometry/#relevant-links","title":"Relevant Links","text":"<ul> <li>Easy geometry using std::complex</li> </ul>"},{"location":"gyms/","title":"Planejamento de Gyms","text":"<ul> <li>Universal Cup. Stage 4: Ukraine</li> <li>Universal Cup. Stage 9: Qingdao</li> <li>Universal Cup. Stage 14: Ranoa</li> <li>2022 ICPC Southeastern Europe</li> <li>The 2021 ICPC Asia Nanjing</li> </ul>"},{"location":"kosaraju/","title":"Kosaraju","text":"<p>Can be used to find strongly connected components.</p> Kosaraju<pre><code>struct Kosaraju {\nconst int n;\nV&lt;V&lt;int&gt;&gt; G, Ginv;\nV&lt;bool&gt; vis;\nV&lt;int&gt; comp;\nstack&lt;int&gt; S;\nexplicit Kosaraju(int n) : n(n), G(n), Ginv(n), comp(n, -1) {}\nauto add_edge(int v, int u) {\nG[v].pb(u);\nGinv[u].pb(v);\n}\nauto dfs(int v) -&gt; void {\nvis[v] = true;\nfor (auto u : G[v]) if (!vis[u]) dfs(u);\nS.push(v);\n}\nauto scc(int v, int c) -&gt; void {\nvis[v] = true; comp[v] = c;\nfor (auto u : Ginv[v]) if (!vis[u]) scc(u, c);\n}\nauto run() {\nvis.assign(n, false);\nloop (i, n) if (!vis[i]) dfs(i);\nvis.assign(n, false);\nint cc = 0;\nwhile (!S.empty()) {\nint v = S.top(); S.pop();\nif (!vis[v]) scc(v, cc++);\n}\n}\n};\n</code></pre>"},{"location":"seg/","title":"Segment Tree","text":""},{"location":"seg/#implemention","title":"Implemention","text":"Segment Tree<pre><code>template&lt;typename T&gt;\nclass SegmentTree {\nint n;\nT neutral;\nV&lt;T&gt; t;\nstd::function&lt;T(T,T)&gt; merge;\npublic:\nSegmentTree(int n, T neutral,\nstd::function&lt;T(T,T)&gt; merge) {\nthis-&gt;n = n;\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\nt.assign(2*n, neutral);\n}\nSegmentTree(V&lt;T&gt; &amp;v, T neutral,\nstd::function&lt;T(T,T)&gt; merge) {\nthis-&gt;n = v.size();\nthis-&gt;neutral = neutral;\nthis-&gt;merge = merge;\nt.assign(2*n, neutral);\nloop (i, n) t[i+n] = v[i];\nbuild();\n}\nvoid build() {\nfor (int i=n-1; i&gt;0; i--)\nt[i]=merge(t[2*i],t[2*i+1]);\n}\nT query(int l, int r) {\nT rl = neutral, rr = neutral;\nfor (l+=n, r+=n+1; l&lt;r; l/=2, r/=2) {\nif (l&amp;1) rl = merge(rl, t[l++]);\nif (r&amp;1) rr = merge(t[--r], rr);\n}\nreturn merge(rl, rr);\n}\nvoid update(int p, T val) {\nfor (t[p+=n]=val; p &gt; 1; p /= 2)\nt[p/2] = merge(t[min(p, p^1)], t[max(p, p^1)]);\n}\n};\n</code></pre> Usage example<pre><code>// Lambda macro\n#define L2(res ...) [](auto x, auto y){ return res; }\n// Addition Seg\nSegmentTree&lt;int&gt; seg_add(n, 0, L2(x+y));\n// Maximum Seg\nSegmentTree&lt;int&gt; seg_max(n, -INF, L2(max(x,y)));\n// Minimum and Maximum Seg\nSegmentTree&lt;ii&gt; seg_minmax(n, {INF, -INF}, L2(min(x.ff, y.ff), max(x.ss, y.ss)));\n</code></pre>"},{"location":"template/","title":"Template","text":""},{"location":"template/#full-template","title":"Full Template","text":"Full template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// Template (v1.4.3 - 2023-04-22) (codeforces:cebolinha, atcoder:edu) {{{\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntemplate&lt;class T&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#define int long long\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\ntemplate&lt;class T&gt; using V = vector&lt;T&gt;;\ntemplate&lt;class T&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;\nusing ii = pair&lt;int, int&gt;;\nusing iii = array&lt;int, 3&gt;;\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define eb emplace_back\n#define ff first\n#define ss second\n#define nemo &gt;&lt;&gt;\n#define loop(ii, n) for (int ii = 0; ii &lt; (n); ii++)\n#define cond(c, t, f) ((c) ? (t) : (f))\n#define mem(a, b) memset((a), (b), sizeof(a))\n#define inbounds(x, l, r) ((l) &lt;= (x) &amp;&amp; (x) &lt;= (r))\n#define L1(res...) [&amp;](auto x){ return res; }\n#define L2(res...) [&amp;](auto x, auto y){ return res; }\ntemplate&lt;class T, class U&gt; inline void miq(T&amp; a, U b){ if (a &gt; b) a = b; }\ntemplate&lt;class T, class U&gt; inline void maq(T&amp; a, U b){ if (a &lt; b) a = b; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, U&gt; &amp;p) { return is &gt;&gt; p.ff &gt;&gt; p.ss; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, U&gt; const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; ')'; }\nconst auto EMPTY_STRING = \"\", SEPARATOR = \" \";\ntemplate&lt;class T&gt; auto &amp;operator&gt;&gt;(istream&amp; is, vector&lt;T&gt; &amp;c) { for (auto &amp;x : c) is &gt;&gt; x; return is; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, vector&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, multiset&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, ordered_set&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, deque&lt;T&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, map&lt;K,V&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_map&lt;K,V&gt; const &amp;c) { auto sep = EMPTY_STRING; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEPARATOR; return os; }\ntemplate&lt;class... A&gt; void in(A &amp;...a) { ((cin &gt;&gt; a), ...); }\ntemplate&lt;class... A&gt; void out(A const&amp;... a) { auto sep = EMPTY_STRING; ((cout &lt;&lt; sep &lt;&lt; a, sep = SEPARATOR), ...); cout &lt;&lt; '\\n'; }\ntemplate&lt;class... A&gt; void print(A const&amp;... a) { ((cout &lt;&lt; a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate&lt;class... A&gt; void db(A const&amp;... a) { ((cout &lt;&lt; (a)), ...); cout &lt;&lt; endl; }\n//}}}\nauto main() -&gt; signed {\nfastio;\n}\n</code></pre>"},{"location":"template/#better-io","title":"Better I/O","text":"<p>These three functions can be used to make <code>cin</code> and <code>cout</code> a little more ergonomic.</p> <p>Space at the end of out</p> <p>Out produces a space at the end of the line, before <code>endl</code>. Some online judges may complain about that. Happens a lot on sites like Beecrowd, UVa, and Codeforces Gyms.</p> Better I/O<pre><code>template &lt;typename... A&gt; void in(A &amp;...a) {\n((cin &gt;&gt; a), ...);\n}\ntemplate &lt;typename... A&gt; void out(A... a) {\n((cout &lt;&lt; a &lt;&lt; \" \"), ...); cout &lt;&lt; endl;\n}\ntemplate &lt;typename... A&gt; void print(A... a) {\n((cout &lt;&lt; a), ...);\n}\n</code></pre> Usage example<pre><code>in(x, y, z); // cin &gt;&gt; x &gt;&gt; y &gt;&gt; z\nout(x, y, z); // cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; \" \" &lt;&lt; endl;\nprint(x, y, z); // cout &lt;&lt; x &lt;&lt; y &lt;&lt; z;\n</code></pre>"},{"location":"template/#container-io","title":"Container I/O","text":"<p>Very useful functions that allow you to read and output vectors in a compact way. Can be used with the \"Better I/O\" or regular \"iostream\" functions.</p> Container I/O<pre><code>template &lt;class T&gt;\nistream &amp;operator&gt;&gt;(istream &amp;is, vector&lt;T&gt; &amp;v) {\nfor (auto &amp;a : v) is &gt;&gt; a;\nreturn is;\n}\ntemplate &lt;class T&gt;\nostream &amp;operator&lt;&lt;(ostream &amp;os, vector&lt;T&gt; v) {\nloop(i, sz(v)) os &lt;&lt; cond(i,\" \",\"\") &lt;&lt; v[i];\nreturn os;\n}\n</code></pre> Usage examples<pre><code>V&lt;int&gt; v(n); in(v); out(v);\nV&lt;int&gt; v(n); cin &gt;&gt; v; cout &lt;&lt; v;\nset&lt;int&gt; S{1, 2, 3}; out(s);\n</code></pre>"},{"location":"template/#debug-macro","title":"Debug macro","text":"<p>Prints a variable's name next to its name.</p> Debug Macro<pre><code>#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate &lt;typename... A&gt; void db(A... a) {\n((cout &lt;&lt; var(a)), ...); cout &lt;&lt; endl;\n}\n</code></pre> Usage example<pre><code>int x = 5; db(x); // [x 5]\nV&lt;int&gt; v{1, 2, 3}; db(v); // [v 1 2 3]\n</code></pre>"},{"location":"template/#pragmas","title":"Pragmas","text":"<p>Enables some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them.</p> Pragmas<pre><code>#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n</code></pre>"},{"location":"editorial/unbdesc2023/","title":"UnBDESC 2023","text":"<p>Link para submeter as quest\u00f5es</p>"},{"location":"editorial/unbdesc2023/#fibonacci-string","title":"Fibonacci String","text":"<p>Podemos pr\u00e9-calcular facilmente quantas letras temos em \\(F_0, F_1, F_2\\dots\\), esse ser\u00e1 o vetor <code>AB</code> abaixo. Tamb\u00e9m guardaremos o tamanho de cada uma dessas palavras em <code>LEN</code>.</p> <p>Queremos saber as quantidades de \\(a\\) e \\(b\\) em \\(\\mathcal{F}[L, R]\\). Podemos fazer isso conseguindo essas quantidades em \\(\\mathcal{F}[0,R]\\) e removendo as quantidades em \\(\\mathcal{F}[0,L-1]\\).</p> <p>Quando pegamos um prefixo de \\(\\mathcal{F}\\), vamos pegar v\u00e1rias strings completas, mais um prefixo de uma palavra que ficou incompleta. Fazemos isso na fun\u00e7\u00e3o <code>ab_count</code>, que adiciona as letras de palavras completas enquanto o total n\u00e3o ultrapassa a quantidade de letras que queremos. No fim, ela chama a fun\u00e7\u00e3o <code>word_prefix</code> que acha a quantidade de cada letra num prefixo dessa palavra incompleta.</p> <p>A fun\u00e7\u00e3o <code>word_prefix</code> tem dois casos base. Se o prefixo que queremos tem tamanho \\(0\\), as quantidades s\u00e3o \\(0\\). Al\u00e9m disso, criamos casos especiais para a primeira e a segunda palavra.</p> <p>O principal fato que deve ser notado \u00e9 que como \\(F_k = F_{k-1} \\oplus F_{k-2}\\), se temos um prefixo de \\(F_k\\) que \u00e9 menor ou igual \u00e0 \\(F_{k-1}\\), ele \u00e9 equivalente \u00e0 um prefixo do mesmo tamanho de \\(F_{k-1}\\). Sen\u00e3o, ele \u00e9 \\(F_{k-1}\\) por completo, mais um prefixo de \\(F_{k-2}\\). Assim, podemos definir <code>word_prefix</code> recursivamente de uma forma simples.</p> <p>Complexidade: \\(\\mathcal{O}(\\log_\\varphi R)\\)? \u00c9 t\u00e3o r\u00e1pido que nem importa</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define int long long\npair&lt;int, int&gt; operator+(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\nreturn {a.first + b.first, a.second + b.second};\n}\nconst int MAXF = 86;\npair&lt;int, int&gt; AB[MAXF];\nint LEN[MAXF];\npair&lt;int, int&gt; word_prefix(int idx, int len) {\nif (len == 0) return {0, 0};\nif (idx == 0 || idx == 1) return AB[idx];\nif (len &lt;= LEN[idx-1]) return word_prefix(idx-1, len);\nreturn AB[idx-1] + word_prefix(idx-2, len-LEN[idx-1]);\n}\npair&lt;int, int&gt; ab_count(int prefix_len) {\nint idx = 0;\nint len = 0;\npair&lt;int, int&gt; ab{0, 0};\nwhile (len + LEN[idx] &lt;= prefix_len) {\nab = ab + AB[idx];\nlen += LEN[idx];\nidx++;\n}\nint left = prefix_len - len;\nreturn ab + word_prefix(idx, left);\n}\nsigned main() {\nAB[0] = {0, 1}; LEN[0] = 1;\nAB[1] = {1, 0}; LEN[1] = 1;\nfor (int i = 2; i &lt; MAXF; i++) {\nAB[i] = AB[i-1] + AB[i-2];\nLEN[i] = LEN[i-1] + LEN[i-2];\n}\nint l, r;\ncin &gt;&gt; l &gt;&gt; r;\nauto [ra, rb] = ab_count(r+1);\nauto [la, lb] = ab_count(l);\ncout &lt;&lt; ra-la &lt;&lt; ' ' &lt;&lt; rb-lb &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#interruptores","title":"Interruptores","text":"<p>Para simplificar o c\u00f3digo, convertemos os valores do vetor de \\((1, 0, -1)\\) para \\((0, 1, 2)\\).</p> <p>Fazemos uma DP que guarda para \\((i, j)\\) o menor custo para obter \\(A_0 \\dots A_i\\) com \\(A_i = j\\). A DP \u00e9 baseada do fato que para obter \\(A_0 \\dots A_i\\), devemos primeiro obter \\(A_0 \\dots A_{i-1}\\) com \\(A_{i-1} = j \\text{ ou } j-1\\) e depois adicionar \\(A_i = j\\). Devemos somar o custo \\(1\\) para mudar o estado do interruptor caso \\(A_i \\neq j\\).</p> <p>Para \\(i=0\\) temos os casos base: \\(D_{(0,0)} = A_0 \\neq 0, D_{(0, 1)} = \\infty, D_{(0, 2)} = \\infty\\).</p> <p>Para \\(i&gt;0\\), temos:</p> \\[ D_{(i, j)} = min \\begin{cases}     D_{(i-1, j)}\\\\     D_{(i-1, j-1)} \\text{ para } j &gt; 0 \\end{cases} + (A_i \\neq j) \\] <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nint n;\nint A[100'000 + 8];\nint DP[100'000 + 8][3];\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\ncin &gt;&gt; n;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nif (A[i] == +1) A[i] = 0;\nelse if (A[i] ==  0) A[i] = 1;\nelse if (A[i] == -1) A[i] = 2;\n}\nDP[0][0] = (A[0] != 0);\nDP[0][1] = DP[0][2] = INF;\nfor (int i = 1; i &lt; n; i++) {\nfor (int j = 0; j &lt; 3; j++) {\nDP[i][j] = DP[i-1][j] + (A[i] != j);\nif (j-1 &gt;= 0) {\nDP[i][j] = min(DP[i][j], DP[i-1][j-1] + (A[i] != j));\n}\n}\n}\ncout &lt;&lt; DP[n-1][2] &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#jovem-aprendiz","title":"Jovem Aprendiz","text":"<p>Essa foi a quest\u00e3o com mais submiss\u00f5es da prova (151, ou 31.0%). Foram 12 RTEs, 35 TLEs, 74 WAs e 30 ACs.</p> <p>Muitos dos WAs foram causados por overflows, que podem ser resolvidos trocando <code>int</code> por <code>long long</code>.</p> <p>Os TLEs foram causados pelo fato da solu\u00e7\u00e3o \"naive\" n\u00e3o ser r\u00e1pida o suficiente. Se o monstro tem muita vida (como \\(10^{18}\\)) e os ataques s\u00e3o muito fracos (como \\(1\\) ou \\(2\\)), \u00e9 necess\u00e1ria uma quantidade enorme de ataques para matar o monstro.</p> <p>Um jeito de resolver isso \u00e9 pr\u00e9-calcular a soma dos danos dos \\(N\\) ataques. Digamos que o monstro tem \\(5000\\) de vida e os \\(N\\) ataques d\u00e3o \\(17\\) de dano no total. Podemos ver que o mago usar\u00e1 um ciclo de todos seus ataques pelo menos \\(\\lfloor5000/17\\rfloor = 294\\) vezes. Depois disso resta \\(2\\) de vida, e podemos ir aplicando os ataques um por um enquanto o monstro n\u00e3o morrer.</p> <p>A quantidade de ataques que vai restar ap\u00f3s retirarmos os ciclos completos \u00e9 sempre menor ou igual \u00e0 \\(N\\), pois a vida que sobra \u00e9 menor que o dano de um ciclo de ataques. Assim o loop que vai aplicando o dano de cada ataque enquanto o monstro estiver vivo n\u00e3o vai rodar mais do que \\(N\\) vezes, sendo r\u00e1pido o suficiente.</p> <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nlong long A[100'000 + 8];\nint main() {\nlong long n, m;\ncin &gt;&gt; n &gt;&gt; m;\nlong long sum = 0;\nfor (int i = 0; i &lt; n; i++) {\ncin &gt;&gt; A[i];\nsum += A[i];\n}\nlong long ans = (m/sum) * n;\nm %= sum;\nfor (int i = 0; i &lt; n; i++) {\nm -= A[i];\nans++;\nif (m &lt;= 0) break;\n}\ncout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre>"},{"location":"editorial/unbdesc2023/#keyboard","title":"Keyboard","text":"<p>O enunciado n\u00e3o garante que n\u00e3o v\u00e3o ter dois n\u00fameros iguais seguidos na sequ\u00eancia de digita\u00e7\u00e3o. O jeito mais f\u00e1cil de lidar com isso \u00e9 quando for ler a sequ\u00eancia ignorar os n\u00fameros que s\u00e3o iguais ao n\u00famero anterior.</p> <p>Depois disso \u00e9 s\u00f3 fazer uma BFS, onde em vez do estado ser \\((i, j)\\), ele \u00e9 \\((i, j, \\text{done})\\), onde \\(\\text{done}\\) \u00e9 a quantidade de itens da sequ\u00eancia que j\u00e1 foram satisfeitos. O c\u00f3digo abaixo \u00e9 bem auto-explicativo.</p> <p>Complexidade: \\(\\mathcal{O}(N\\cdot M\\cdot Q)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst vector&lt;pair&lt;int, int&gt;&gt; delta{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nint main() {\nios::sync_with_stdio(false); cin.tie(nullptr);\nint n, m;\ncin &gt;&gt; n &gt;&gt; m;\nvector grid(n, vector&lt;int&gt;(m));\nfor (int i = 0; i &lt; n; i++)\nfor (int j = 0; j &lt; m; j++)\ncin &gt;&gt; grid[i][j];\nint q; cin &gt;&gt; q;\nvector&lt;int&gt; path;\nfor (int i = 0; i &lt; q; i++) {\nint x; cin &gt;&gt; x;\nif (path.empty() || path.back() != x)\npath.push_back(x);\n}\nq = size(path);\nvector dist(n, vector(m, vector&lt;int&gt;(q+1, -1)));\nqueue&lt;array&lt;int, 4&gt;&gt; Q;\nint first_done = path[0] == grid[0][0];\nQ.push({0, 0, 0, first_done});\nwhile (!Q.empty()) {\nauto [vd, vi, vj, vdone] = Q.front(); Q.pop();\nif (vdone == q) return cout &lt;&lt; vd &lt;&lt; endl, 0;\nfor (auto [di, dj] : delta) {\nint ui = vi + di, uj = vj + dj;\nif (!(0 &lt;= ui &amp;&amp; ui &lt; n)) continue;\nif (!(0 &lt;= uj &amp;&amp; uj &lt; m)) continue;\nint udone = vdone + (grid[ui][uj] == path[vdone]);\nif (dist[ui][uj][udone] == -1) {\ndist[ui][uj][udone] = vd + 1;\nQ.push({vd+1, ui, uj, udone});\n}\n}\n}\n}\n</code></pre>"}]}