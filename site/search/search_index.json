{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FLAMENGO","title":"FLAMENGO"},{"location":"#flamengo","text":"","title":"FLAMENGO"},{"location":"dfslowlink/","text":"DFS Lowlink Technique for finding bridges and articulation points. Video explaining the concept: YouTube - DFS Lowlink . Implementation Problems SPOJ - Manuten\u00e7\u00e3o - Finding articulation points SPOJ - Critical Edges - Finding bridges","title":"DFS Lowlink"},{"location":"dfslowlink/#dfs-lowlink","text":"Technique for finding bridges and articulation points. Video explaining the concept: YouTube - DFS Lowlink .","title":"DFS Lowlink"},{"location":"dfslowlink/#implementation","text":"","title":"Implementation"},{"location":"dfslowlink/#problems","text":"SPOJ - Manuten\u00e7\u00e3o - Finding articulation points SPOJ - Critical Edges - Finding bridges","title":"Problems"},{"location":"dsu/","text":"Disjoint Set Union Implementation Warning The implementation uses indexes $$0 \u2264 i < n-1$$ DSU struct DSU { vector < int > p , s ; DSU ( int n ) { p . assign ( n , -1 ), s . assign ( n , 1 ); } int find ( int v ) { if ( p [ v ] == -1 ) return v ; return p [ v ] = find ( p [ v ]); } void join ( int a , int b ) { a = find ( a ), b = find ( b ); if ( a != b ) { if ( s [ a ] < s [ b ]) swap ( a , b ); p [ b ] = a , s [ a ] += s [ b ]; } } }; This implementation can be tested on Library Checker - Unionfind . [Submission] Problems Codeforces 25D - Roads Not Only in Berland","title":"Disjoint Set Union"},{"location":"dsu/#disjoint-set-union","text":"","title":"Disjoint Set Union"},{"location":"dsu/#implementation","text":"Warning The implementation uses indexes $$0 \u2264 i < n-1$$ DSU struct DSU { vector < int > p , s ; DSU ( int n ) { p . assign ( n , -1 ), s . assign ( n , 1 ); } int find ( int v ) { if ( p [ v ] == -1 ) return v ; return p [ v ] = find ( p [ v ]); } void join ( int a , int b ) { a = find ( a ), b = find ( b ); if ( a != b ) { if ( s [ a ] < s [ b ]) swap ( a , b ); p [ b ] = a , s [ a ] += s [ b ]; } } }; This implementation can be tested on Library Checker - Unionfind . [Submission]","title":"Implementation"},{"location":"dsu/#problems","text":"Codeforces 25D - Roads Not Only in Berland","title":"Problems"},{"location":"seg/","text":"Segment Tree Implemention Segment Tree template < typename T > class SegmentTree { int n ; T neutral ; V < T > t ; std :: function < T ( T , T ) > merge ; public : SegmentTree ( int n , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = n ; this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); } SegmentTree ( V < T > & v , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = v . size (); this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); loop ( i , n ) t [ i + n ] = v [ i ]; build (); } void build () { for ( int i = n -1 ; i > 0 ; i -- ) t [ i ] = merge ( t [ 2 * i ], t [ 2 * i + 1 ]); } T query ( int l , int r ) { T rl = neutral , rr = neutral ; for ( l += n , r += n + 1 ; l < r ; l /= 2 , r /= 2 ) { if ( l & 1 ) rl = merge ( rl , t [ l ++ ]); if ( r & 1 ) rr = merge ( t [ -- r ], rr ); } return merge ( rl , rr ); } void update ( int p , T val ) { for ( t [ p += n ] = val ; p > 1 ; p /= 2 ) t [ p / 2 ] = merge ( t [ min ( p , p ^ 1 )], t [ max ( p , p ^ 1 )]); } }; Usage example // Lambda macro #define L2(res ...) [](auto x, auto y){ return res; } // Addition Seg SegmentTree < int > seg_add ( n , 0 , L2 ( x + y )); // Maximum Seg SegmentTree < int > seg_max ( n , - INF , L2 ( max ( x , y ))); // Minimum and Maximum Seg SegmentTree < ii > seg_minmax ( n , { INF , - INF }, L2 ( min ( x . ff , y . ff ), max ( x . ss , y . ss )));","title":"Segment Tree"},{"location":"seg/#segment-tree","text":"","title":"Segment Tree"},{"location":"seg/#implemention","text":"Segment Tree template < typename T > class SegmentTree { int n ; T neutral ; V < T > t ; std :: function < T ( T , T ) > merge ; public : SegmentTree ( int n , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = n ; this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); } SegmentTree ( V < T > & v , T neutral , std :: function < T ( T , T ) > merge ) { this -> n = v . size (); this -> neutral = neutral ; this -> merge = merge ; t . assign ( 2 * n , neutral ); loop ( i , n ) t [ i + n ] = v [ i ]; build (); } void build () { for ( int i = n -1 ; i > 0 ; i -- ) t [ i ] = merge ( t [ 2 * i ], t [ 2 * i + 1 ]); } T query ( int l , int r ) { T rl = neutral , rr = neutral ; for ( l += n , r += n + 1 ; l < r ; l /= 2 , r /= 2 ) { if ( l & 1 ) rl = merge ( rl , t [ l ++ ]); if ( r & 1 ) rr = merge ( t [ -- r ], rr ); } return merge ( rl , rr ); } void update ( int p , T val ) { for ( t [ p += n ] = val ; p > 1 ; p /= 2 ) t [ p / 2 ] = merge ( t [ min ( p , p ^ 1 )], t [ max ( p , p ^ 1 )]); } }; Usage example // Lambda macro #define L2(res ...) [](auto x, auto y){ return res; } // Addition Seg SegmentTree < int > seg_add ( n , 0 , L2 ( x + y )); // Maximum Seg SegmentTree < int > seg_max ( n , - INF , L2 ( max ( x , y ))); // Minimum and Maximum Seg SegmentTree < ii > seg_minmax ( n , { INF , - INF }, L2 ( min ( x . ff , y . ff ), max ( x . ss , y . ss )));","title":"Implemention"},{"location":"template/","text":"Template Base Template A small collection of abbreviations and macros that are used very frequently. There is also a #define int long long in the beginning of the file. This usually doubles the memory usage of integers, but that rarely causes problems. The benefits of not getting overflow errors make it worth it. There are also two very useful functions miq and maq . miq(a, b) makes a the minimum between a and b , whereas maq(a, b) makes a the maximum between a and b . Loop bounds loop(i, n) loops through (0 \u2264 i < n) xloop(i, l, r) loops through (l \u2264 i \u2264 r). Base template #include <bits/stdc++.h> using namespace std ; #define int long long template < typename T > using V = vector < T > ; using ii = pair < int , int > ; using iii = tuple < int , int , int > ; using ll = long long ; #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend() #define sz(v) (int)v.size() #define loop(ii, n) for (int ii = 0; ii < (n); ++ii) #define xloop(ii, l, r) for (int ii = (l); ii <= (r); ++ii) // (1)! #define cond(c, t, f) ((c) ? (t) : (f)) #define mem(a, b) memset(a, (b), sizeof(a)) #define inbounds(x, l, r) ((l) <= (x) && (x) <= (r)) #define nemo ><> #define ff first #define ss second #define pb push_back #define eb emplace_back template < typename T , typename U > inline void miq ( T & a , U & const b ){ if ( a > b ) a = b ;} template < typename T , typename U > inline void maq ( T & a , U & const b ){ if ( a < b ) a = b ;} #define fastio ios::sync_with_stdio(false); cin.tie(nullptr); signed main () { fastio } Better I/O These three functions can be used to make cin and cout a little more ergonomic. Space at the end of out Out produces a space at the end of the line, before endl . Some online judges may complain about that. Happens a lot on sites like Beecrowd, UVa, and Codeforces Gyms. Better I/O template < typename ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < typename ... A > void out ( A ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < typename ... A > void print ( A ... a ) { (( cout << a ), ...); } Usage example in ( x , y , z ); // same as cin >> x >> y >> z out ( x , y , z ); // same as cout << x << \" \" << y << \" \" << z << \" \" << endl; print ( x , y , z ); // same as cout << x << y << z; Container I/O Very useful functions that allow you to read and output vectors in a compact way. Can be used with the \"Better I/O\" or regular \"iostream\" functions. Container I/O template < typename T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < typename T > ostream & operator << ( ostream & os , vector < T > v ) { loop ( i , sz ( v )) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } template < typename T > ostream & operator << ( ostream & os , set < T > v ) { for ( auto it = v . begin (); it != v . end (); it ++ ) os << cond ( it != v . begin (), \" \" , \"\" ) << * it ; return os ; } Usage examples V < int > v ( n ); in ( v ); out ( v ); V < int > v ( n ); cin >> v ; cout << v ; set < int > S { 1 , 2 , 3 }; out ( s ); Debug macro Prints a variable's name next to its name. Debug Macro #define var(x) \"[\", #x, \" \", x, \"] \" template < typename ... A > void db ( A ... a ) { (( cout << var ( a )), ...); cout << endl ; } Usage example int x = 5 ; db ( x ); // [x 5] V < int > v { 1 , 2 , 3 }; db ( v ); // [v 1 2 3] Pragmas Enables some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them. Pragmas #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\")","title":"Template"},{"location":"template/#template","text":"","title":"Template"},{"location":"template/#base-template","text":"A small collection of abbreviations and macros that are used very frequently. There is also a #define int long long in the beginning of the file. This usually doubles the memory usage of integers, but that rarely causes problems. The benefits of not getting overflow errors make it worth it. There are also two very useful functions miq and maq . miq(a, b) makes a the minimum between a and b , whereas maq(a, b) makes a the maximum between a and b . Loop bounds loop(i, n) loops through (0 \u2264 i < n) xloop(i, l, r) loops through (l \u2264 i \u2264 r). Base template #include <bits/stdc++.h> using namespace std ; #define int long long template < typename T > using V = vector < T > ; using ii = pair < int , int > ; using iii = tuple < int , int , int > ; using ll = long long ; #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend() #define sz(v) (int)v.size() #define loop(ii, n) for (int ii = 0; ii < (n); ++ii) #define xloop(ii, l, r) for (int ii = (l); ii <= (r); ++ii) // (1)! #define cond(c, t, f) ((c) ? (t) : (f)) #define mem(a, b) memset(a, (b), sizeof(a)) #define inbounds(x, l, r) ((l) <= (x) && (x) <= (r)) #define nemo ><> #define ff first #define ss second #define pb push_back #define eb emplace_back template < typename T , typename U > inline void miq ( T & a , U & const b ){ if ( a > b ) a = b ;} template < typename T , typename U > inline void maq ( T & a , U & const b ){ if ( a < b ) a = b ;} #define fastio ios::sync_with_stdio(false); cin.tie(nullptr); signed main () { fastio }","title":"Base Template"},{"location":"template/#better-io","text":"These three functions can be used to make cin and cout a little more ergonomic. Space at the end of out Out produces a space at the end of the line, before endl . Some online judges may complain about that. Happens a lot on sites like Beecrowd, UVa, and Codeforces Gyms. Better I/O template < typename ... A > void in ( A & ... a ) { (( cin >> a ), ...); } template < typename ... A > void out ( A ... a ) { (( cout << a << \" \" ), ...); cout << endl ; } template < typename ... A > void print ( A ... a ) { (( cout << a ), ...); } Usage example in ( x , y , z ); // same as cin >> x >> y >> z out ( x , y , z ); // same as cout << x << \" \" << y << \" \" << z << \" \" << endl; print ( x , y , z ); // same as cout << x << y << z;","title":"Better I/O"},{"location":"template/#container-io","text":"Very useful functions that allow you to read and output vectors in a compact way. Can be used with the \"Better I/O\" or regular \"iostream\" functions. Container I/O template < typename T > istream & operator >> ( istream & is , vector < T > & v ) { for ( auto & a : v ) is >> a ; return is ; } template < typename T > ostream & operator << ( ostream & os , vector < T > v ) { loop ( i , sz ( v )) os << cond ( i , \" \" , \"\" ) << v [ i ]; return os ; } template < typename T > ostream & operator << ( ostream & os , set < T > v ) { for ( auto it = v . begin (); it != v . end (); it ++ ) os << cond ( it != v . begin (), \" \" , \"\" ) << * it ; return os ; } Usage examples V < int > v ( n ); in ( v ); out ( v ); V < int > v ( n ); cin >> v ; cout << v ; set < int > S { 1 , 2 , 3 }; out ( s );","title":"Container I/O"},{"location":"template/#debug-macro","text":"Prints a variable's name next to its name. Debug Macro #define var(x) \"[\", #x, \" \", x, \"] \" template < typename ... A > void db ( A ... a ) { (( cout << var ( a )), ...); cout << endl ; } Usage example int x = 5 ; db ( x ); // [x 5] V < int > v { 1 , 2 , 3 }; db ( v ); // [v 1 2 3]","title":"Debug macro"},{"location":"template/#pragmas","text":"Enables some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them. Pragmas #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\")","title":"Pragmas"}]}