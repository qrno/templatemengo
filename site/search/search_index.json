{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#team-members","title":"Team Members","text":"<ul> <li>vilsu / vilsu</li> <li>cebolinha / edu</li> <li>eyz / eyz</li> </ul>"},{"location":"#links","title":"Links","text":""},{"location":"#code-notebooks","title":"Code Notebooks","text":"<ul> <li>Templatemengo</li> <li>Tiagodfs</li> <li>WeakestTopology</li> <li>brunomont</li> <li>NUS</li> <li>KACTL</li> </ul>"},{"location":"#problem-lists","title":"Problem Lists","text":"<ul> <li>AtCoder Problems</li> <li>Codeforces Problems</li> <li>Dynamic A2OJ</li> <li>OI Checklist</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>USACO Guide</li> <li>CP-Algorithms</li> <li>Algorithms Live!</li> </ul>"},{"location":"base/template/","title":"Full Template","text":""},{"location":"base/template/#code","title":"Code","text":"Full template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Template (v1.5.2 - 2023-10-09) (codeforces:cebolinha, atcoder:edu) {{{\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntemplate&lt;class T&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;;\n\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n\n#define int long long\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\n\ntemplate&lt;class T&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;\nusing ii = pair&lt;int, int&gt;;\nusing iii = array&lt;int, 3&gt;;\n\n#define V vector\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define sz(c) ((int)size(c))\n#define pb push_back\n#define eb emplace_back\n#define ff first\n#define ss second\n#define nemo &gt;&lt;&gt;\n#define loop(ii, n) for (int ii = 0; ii &lt; (n); ii++)\n#define iloop(ii, l, r) for (int ii = (l); ii &lt;= (r); ii++)\n#define cond(c, t, f) ((c) ? (t) : (f))\n#define mem(a, b) memset((a), (b), sizeof(a))\n#define inbounds(x, l, r) ((l) &lt;= (x) &amp;&amp; (x) &lt;= (r))\n#define L1(res...) [&amp;](auto const&amp; x){ return res; }\n#define L2(res...) [&amp;](auto const&amp; x, auto const&amp; y){ return res; }\n\ntemplate&lt;class T, class U&gt; inline void chmin(T&amp; a, U b){ if (a &gt; b) a = b; }\ntemplate&lt;class T, class U&gt; inline void chmax(T&amp; a, U b){ if (a &lt; b) a = b; }\n\ntemplate&lt;class T, class U&gt; auto &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, U&gt; &amp;p) { return is &gt;&gt; p.ff &gt;&gt; p.ss; }\ntemplate&lt;class T, class U&gt; auto &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, U&gt; const&amp; p) { return os &lt;&lt; '{' &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '}'; }\n\nconst auto ES = \"\", SEP = \" \";\ntemplate&lt;class T&gt; auto &amp;operator&gt;&gt;(istream&amp; is, vector&lt;T&gt; &amp;c) { for (auto &amp;x : c) is &gt;&gt; x; return is; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, vector&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, multiset&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, ordered_set&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class T&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, deque&lt;T&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, map&lt;K,V&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\ntemplate&lt;class K, class V&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, unordered_map&lt;K,V&gt; const &amp;c) { auto sep = ES; for (auto x : c) os &lt;&lt; sep &lt;&lt; x, sep = SEP; return os; }\n\ntemplate&lt;class... A&gt; void in(A &amp;...a) { ((cin &gt;&gt; a), ...); }\ntemplate&lt;class... A&gt; void out(A const&amp;... a) { auto sep = ES; ((cout &lt;&lt; sep &lt;&lt; a, sep = SEP), ...); cout &lt;&lt; '\\n'; }\ntemplate&lt;class... A&gt; void print(A const&amp;... a) { ((cout &lt;&lt; a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\ntemplate&lt;class... A&gt; void db(A const&amp;... a) { ((cout &lt;&lt; (a)), ...); cout &lt;&lt; endl; }\n//}}}\n\nauto main() -&gt; signed {\n  fastio;\n\n}\n</code></pre>"},{"location":"base/template/#pragmas","title":"Pragmas","text":"<p>Pragmas enable some GCC optimizations which can make some kinds of code run faster. Reference this Codeforces blog by nor for details on what pragmas do and when to use them.</p>"},{"location":"base/template_beta/","title":"Beta Template","text":"<p>The Full template with some added macros I want to test out before adding permanently.</p>"},{"location":"base/template_beta/#code","title":"Code","text":"Beta template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Template (v2.0.0 beta - 2024-01-01) (codeforces:cebolinha, atcoder:edu) {{{\n#define tcT template&lt;class T\n#define tcTU tcT, class U\n#define tcA template&lt;class...A\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\ntcT&gt; using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag,tree_order_statistics_node_update&gt;;\n\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n\n#define int long long\n\n#define V vector\ntcT&gt; using min_priority_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;\nusing str = string;\nusing ii = pair&lt;int, int&gt;;\nusing iii = array&lt;int, 3&gt;;\n\n#define all(C) begin(C), end(C)\n#define rall(C) rbegin(C), rend(C)\n#define allb(C) begin(C), end(C), begin(C)\n#define sz(C) ((int)size(C))\n\n#define tp top()\n#define ft front()\n#define bk back()\n#define pb push_back\n#define ins insert\n#define ff first\n#define ss second\n#define nemo &gt;&lt;&gt;\n\n#define iloop(I,L,R) for (int I = (L); I &lt;= (R); I++)\n#define loop(I,N) iloop(I,0,(N)-1)\n#define rep(N) loop(_, N)\n#define ipool(I,L,R) for (int I = (R); I &gt;= (L); I--)\n#define pool(I,N) ipool(I,0,(N)-1)\n#define tloop int __T; cin &gt;&gt; __T; while (__T--)\n#define each(X,C) for(auto &amp;X : (C))\n#define eachc(X,C) for(auto const&amp; X : (C))\n#define apply(C,L) each(x,C) L;\n\n#define cond(C, T, F) ((C) ? (T) : (F))\n#define mem(C, X) memset((C), (X), sizeof(C))\n#define ibi(X, L, R) ((L) &lt;= (X) &amp;&amp; (X) &lt;= (R))\n#define ib(X, N) ((0) &lt;= (X) &amp;&amp; (X) &lt;= (N-1))\n#define L1(X...) [&amp;](auto const&amp; x){ return X; }\n#define L2(X...) [&amp;](auto const&amp; x, auto const&amp; y){ return X; }\n\ntcTU&gt; inline bool chmax(T &amp;a, U const&amp; b) { return (a &lt; b ? a = b, 1 : 0); }\ntcTU&gt; inline bool chmin(T &amp;a, U const&amp; b) { return (a &gt; b ? a = b, 1 : 0); }\n\nint cdiv(int a, int b) { return a/b+((a^b)&gt;0&amp;&amp;a%b); }\nint fdiv(int a, int b) { return a/b-((a^b)&lt;0&amp;&amp;a%b); }\n\n#define fastio ios::sync_with_stdio(false); cin.tie(nullptr)\n\ntcTU&gt; auto &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, U&gt; &amp;p) { return is &gt;&gt; p.ff &gt;&gt; p.ss; }\ntcTU&gt; auto &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, U&gt; const&amp; p) { return os &lt;&lt; '{' &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '}'; }\ntcT&gt; auto &amp;operator&gt;&gt;(istream&amp; is, vector&lt;T&gt; &amp;C) { for (auto &amp;x : C) is &gt;&gt; x; return is; }\n\ntcT&gt; struct is_container : std::false_type {};\n#define __ADDC(C) tcA&gt; struct is_container&lt;C&lt;A...&gt;&gt; : std::true_type {};\n__ADDC(vector); __ADDC(set); __ADDC(multiset); __ADDC(unordered_set); __ADDC(map); __ADDC(unordered_map);\n\nconst auto __ES = \"\", __SEP = \" \";\ntcT&gt; enable_if&lt;is_container&lt;T&gt;::value, ostream&gt;::type &amp;operator&lt;&lt;(ostream&amp; os, T const &amp;C) { auto sep = __ES; each(x, C) os &lt;&lt; sep &lt;&lt; x, sep = __SEP; return os; }\ntcT&gt; auto &amp;operator&lt;&lt;(ostream&amp; os, ordered_set&lt;T&gt; const &amp;C) { auto sep = __ES; each(x, C) os &lt;&lt; sep &lt;&lt; x, sep = __SEP; return os; }\n\ntcA&gt; void in(A &amp;...a) { ((cin &gt;&gt; a), ...); }\ntcA&gt; void out(A const&amp;... a) { auto sep = __ES; ((cout &lt;&lt; sep &lt;&lt; a, sep = __SEP), ...); cout &lt;&lt; '\\n'; }\ntcA&gt; void print(A const&amp;... a) { ((cout &lt;&lt; a), ...); }\n#define var(x) \"[\", #x, \" \", x, \"] \"\n#ifdef LOCAL\ntcA&gt; void db(A const&amp;... a) { ((cout &lt;&lt; (a)), ...); cout &lt;&lt; endl; }\n#else\ntcA&gt; void db(A const&amp;... a) {}\n#endif\n//}}}\n\nauto main() -&gt; signed {\n  fastio;\n\n}\n</code></pre>"},{"location":"base/template_minimal/","title":"Minimal Template","text":""},{"location":"base/template_minimal/#code","title":"Code","text":"Minimal template<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(nullptr);\n\n}\n</code></pre>"},{"location":"data_structures/dsu/","title":"Disjoint Set Union","text":""},{"location":"data_structures/dsu/#implementation","title":"Implementation","text":"<p>Includes union by size and path compression optimizations.</p> Disjoint Set Union<pre><code>//{{{ DSU\nstruct DSU {\n  vector&lt;int&gt; P, S;\n  explicit DSU (int N) : P(N, -1), S(N, 1) {};\n  int leader(int a) {\n    if (P[a] == -1) return a;\n    return P[a] = leader(P[a]);\n  }\n  int merge(int a, int b) {\n    a = leader(a);\n    b = leader(b);\n    if (a == b) return a;\n    if (S[a] &lt; S[b]) swap(a, b);\n    P[b] = a;\n    S[a] += S[b];\n    return a;\n  }\n  int same(int a, int b) {\n    return leader(a) == leader(b);\n  }\n};\n//}}}\n</code></pre> <p>This implementation can be tested on Library Checker - Unionfind [Submission]</p>"},{"location":"data_structures/dsu/#problems","title":"Problems","text":"<ul> <li>Codeforces 25D - Roads Not Only in Berland</li> </ul>"},{"location":"data_structures/fenwick_tree/","title":"Fenwick Tree","text":"<p>Does strictly less than a segment tree but is usually a little bit faster and shorter to code.</p>"},{"location":"data_structures/fenwick_tree/#code","title":"Code","text":"Fenwick Tree<pre><code>//{{{ FenwickTree\nstruct FenwickTree {\n  int N;\n  vector&lt;int&gt; data;\n\n  FenwickTree(int N) : N(N), data(N) {}\n\n  void add(int idx, int delta) {\n    for (; idx &lt; N; idx |= idx+1)\n      data[idx] += delta;\n  }\n\n  int sum(int r) {\n    int ret = 0;\n    for (; r &gt;= 0; r &amp;= r+1, r--)\n      ret += data[r];\n    return ret;\n  }\n\n  int sum(int l, int r) {\n    return sum(r) - sum(l-1);\n  }\n};\n//}}}\n</code></pre> <p>Can be tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"data_structures/inversions/","title":"Inversion Counting","text":"<p>Return the number of inversions in a vector. That is, the number of pairs of indices \\({i, j}\\) such that \\(i &lt; j\\) and \\(A_i &gt; A_j\\).</p> <p>Complexity: \\(\\mathcal{O}(N\\log(N))\\)</p>"},{"location":"data_structures/inversions/#code","title":"Code","text":"Inversion Counting<pre><code>// Inversion Counting {{{\nint inversions(vector&lt;int&gt; const&amp; A) {\n  ordered_set&lt;pair&lt;int, int&gt;&gt; OS;\n  int ans = 0;\n  for (int i = 0; i &lt; size(A); i++) {\n    ans += OS.size() - OS.order_of_key({A[i], i});\n    OS.insert({A[i], i});\n  }\n  return ans;\n}\n//}}}\n</code></pre>"},{"location":"data_structures/min_window/","title":"Minimum Window","text":"<p>Specify a window length \\(W\\) and as you push new elements, it will tell you the smallest within \\(W\\) of the last element.</p>"},{"location":"data_structures/min_window/#code","title":"Code","text":"Minimum Window<pre><code>// Minimum Window {{{\n// Be careful with case W = 0\nstruct MinWindow {\n  int W;\n  deque&lt;pair&lt;int, int&gt;&gt; Q;\n\npublic:\n  explicit MinWindow(int W) : W(W) {}\n\n  void push(int idx, int x) {\n    while (!Q.empty() &amp;&amp; Q.front().ff &lt; idx-W+1) Q.pop_front();\n    while (!Q.empty() &amp;&amp; Q.back().ss &gt;= x) Q.pop_back();\n    Q.pb({idx, x});\n  }\n\n  int get() const { return Q.front().ss; }\n};\n//}}}\n</code></pre>"},{"location":"data_structures/min_window/#problems","title":"Problems","text":"<p>A couple problems where this is useful:</p> <ul> <li>(CF797-F) Mice and Holes</li> <li>(CF372-C) Watching Fireworks is Fun</li> <li>(CF1731-D) Valiant's New Map</li> </ul>"},{"location":"data_structures/seg_p1/","title":"Seg da P1","text":"<p>Warning</p> <p>Indexado em 0. Tamb\u00e9m nem testei se funciona.</p> <p>Warning</p> <p>N\u00e3o s\u00f3 copiem, tentem fazer sozinhos e usem s\u00f3 como refer\u00eancia.</p> <pre><code>const int MAXN = 1e5 + 8;\n\nint N;\nint T[4*MAXN];\nvoid update(int idx, int x, int id=1, int il=0, int ir=N-1) {\n  if (il == ir) { T[id] = x; return; }\n  int im = (il+ir)/2;\n  if (idx &lt;= im) update(idx, x, 2*id, il, im);\n  else update(idx, x, 2*id+1, im+1, ir);\n  T[id] = T[2*id] + T[2*id+1];\n}\nint query(int l, int r, int id=1, int il=0, int ir=N-1) {\n  if (r &lt; il || ir &lt; l) return 0;\n  if (l &lt;= il &amp;&amp; ir &lt;= r) return T[id];\n  int im = (il+ir)/2;\n  return query(l, r, 2*id, il, im)\n       + query(l, r, 2*id+1, im+1, ir);\n}\n</code></pre>"},{"location":"data_structures/segment_tree/","title":"Segment Tree","text":""},{"location":"data_structures/segment_tree/#code","title":"Code","text":"<p>Node must have a sum operator, as well as a default constructor which must be the monoid's neutral element.</p> Segment Tree<pre><code>//{{{ Segment Tree\ntemplate&lt;typename T&gt;\nclass SegmentTree {\n  int N;\n  vector&lt;T&gt; data;\npublic:\n  explicit SegmentTree(int N) : N(N), data(2*N) {}\n  explicit SegmentTree(vector&lt;int&gt; const&amp; A) : N(size(A)) {\n    for (int i = 0; i &lt; N; i++) set(i, A[i]);\n  }\n\n  void set(int p, T const&amp; val) {\n    for (data[p+=N]=val; p /= 2;)\n      data[p] = data[2*p]+data[2*p+1];\n  }\n\n  T get(int p) const {\n    return data[p + N];\n  }\n\n  void add(int p, T const&amp; val) {\n    set(p, get(p)+val);\n  }\n\n  T sum(int l, int r)  const {\n    T rl = T(), rr = T();\n    for (l+=N, r+=N+1; l&lt;r; l/=2, r/=2) {\n      if (l&amp;1) rl = rl+data[l++];\n      if (r&amp;1) rr = data[--r]+rr;\n    }\n    return rl+rr;\n  }\n};\n//}}}\n</code></pre> <p>Tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"data_structures/segment_tree/#code-simple","title":"Code (Simple)","text":"<p>This segment tree has a simpler interface in some cases, but I heard that <code>std::function</code> has a little bit of overhead. It runs about 15% slower on Yosupo Probably still faster than a recursive segment tree. If you're doing simple operations on integers it is probably better.</p> <p>On the main implementation, you would need to do this for a max segment tree:</p> <pre><code>struct MaxNode {\n    int x;\n    explicit MaxNode (int x=-INF) : x(x) {}\n    friend MaxNode operator+(MaxNode a, MaxNode b) {\n        return MaxNode(max(a.x, b.x));\n    }\n};\n\nSegmentTree&lt;Node&gt; S(N);\n</code></pre> <p>On this one you can do one of the following:</p> <pre><code>SegmentTreeSimple&lt;int&gt; S(N, -INF, [](int x, int y){return max(x, y);});\nSegmentTreeSimple&lt;int&gt; S(N, -INF, L2(max(x,y))); // with the L2 macro\n</code></pre> Segment Tree Simple<pre><code>//{{{ Segment Tree Simple\ntemplate&lt;typename T&gt;\nclass SegmentTreeSimple {\n  int N;\n  T neutral;\n  vector&lt;T&gt; data;\n  function&lt;T(T,T)&gt; merge;\npublic:\n  SegmentTreeSimple(int N, T neutral, function&lt;T(T,T)&gt; merge) {\n    this-&gt;N = N;\n    this-&gt;neutral = neutral;\n    this-&gt;merge = merge;\n    data.assign(2*N, neutral);\n  }\n\n  SegmentTreeSimple(vector&lt;T&gt; const&amp; A, T neutral, function&lt;T(T,T)&gt; merge) {\n    this-&gt;N = A.size();\n    this-&gt;neutral = neutral;\n    this-&gt;merge = merge;\n    data.resize(2*N);\n    for (int i = 0; i &lt; N; i++) data[i+N] = A[i];\n    for (int i=N-1; i&gt;0; i--)\n      data[i]=merge(data[2*i],data[2*i+1]);\n  }\n\n  void set(int p, T const&amp; val) {\n    for (data[p+=N]=val; p /= 2;)\n      data[p] = merge(data[2*p], data[2*p+1]);\n  }\n\n  T get(int p) const {\n    return data[p + N];\n  }\n\n  void add(int p, T const&amp; val) {\n    set(p, get(p)+val);\n  }\n\n  T sum(int l, int r) const {\n    T rl = neutral, rr = neutral;\n    for (l+=N, r+=N+1; l&lt;r; l/=2, r/=2) {\n      if (l&amp;1) rl = merge(rl, data[l++]);\n      if (r&amp;1) rr = merge(data[--r], rr);\n    }\n    return merge(rl, rr);\n  }\n};\n//}}}\n</code></pre> <p>Tested on Library Checker - Point Add Range Sum [Submission]</p>"},{"location":"geometry/base/","title":"Base Template","text":"<p>One big mess for geometry problems, will probably organize this better someday.</p>"},{"location":"geometry/base/#code","title":"Code","text":"Geometry Base<pre><code>//{{{ Geometry Base\nconst long double EPS = 1e-9;\n\ntemplate&lt;typename T&gt;\nbool eq(T const&amp; a, T const&amp; b) {\n  return abs(a-b) &lt;= EPS;\n}\n\ntemplate&lt;typename T&gt;\nstruct Point {\n  T x, y;\n  Point () : x(0), y(0) {}\n  Point (T x, T y) : x(x), y(y) {}\n\n  Point operator+(Point const&amp; o) const { return { x+o.x, y+o.y }; }\n  Point operator-(Point const&amp; o) const { return { x-o.x, y-o.y }; }\n  Point operator*(T const&amp; t) const { return { x*t, y*t }; }\n  Point operator/(T const&amp; t) const { return { x/t, y/t }; }\n  T operator*(Point const&amp; o) const { return x*o.x + y*o.y; }\n  T operator^(Point const&amp; o) const { return x*o.y - y*o.x; }\n\n  bool operator&lt;(Point const&amp; o) const {\n    if (!eq(x, o.x)) return x &lt; o.x;\n    if (!eq(y, o.y)) return y &lt; o.y;\n    return 0;\n  }\n\n  bool operator==(Point const&amp; o) const {\n    return eq(x, o.x) &amp;&amp; eq(y, o.y);\n  }\n\n  friend ostream&amp; operator&lt;&lt;(ostream&amp; os, Point const&amp; p) {\n    return os &lt;&lt; p.x &lt;&lt; ' ' &lt;&lt; p.y;\n  }\n\n  friend istream&amp; operator&gt;&gt;(istream&amp; is, Point &amp;p) {\n    return is &gt;&gt; p.x &gt;&gt; p.y;\n  }\n};\n\ntemplate&lt;typename T&gt;\nT norm(Point&lt;T&gt; const&amp; a) {\n  return sqrtl(a * a);\n}\n\ntemplate&lt;typename T&gt;\nT norm2(Point&lt;T&gt; const&amp; a) {\n  return a * a;\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; unit(Point&lt;T&gt; const&amp; a) {\n  return a / norm(a);\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; proj(Point&lt;T&gt; const&amp; p, Point&lt;T&gt; const&amp; a, Point&lt;T&gt; const&amp; b) {\n  T len = (p-a) * (b-a) / norm(b-a);\n  return a + unit(b-a) * len;\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; reflection(Point&lt;T&gt; const&amp; p, Point&lt;T&gt; const&amp; a, Point&lt;T&gt; const&amp; b) {\n  return p + 2*(proj(p, a, b)-p);\n}\n\ntemplate&lt;typename T&gt;\nT sarea(Point&lt;T&gt; const&amp; a, Point&lt;T&gt; const&amp; b, Point&lt;T&gt; const&amp; c) {\n  return ((b-a)^(c-b))/2;\n}\n\ntemplate&lt;typename T&gt;\nint side(Point&lt;T&gt; const&amp; p, Point&lt;T&gt; const&amp; a, Point&lt;T&gt; const&amp; b) {\n  T x = (b-a) ^ (p-a);\n  return (x &gt; EPS) - (x &lt; -EPS);\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; rot(Point&lt;T&gt; const&amp; p, long double a) {\n  return Point{p.x * cos(a) - p.y * sin(a),\n               p.y * cos(a) + p.x * sin(a)};\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; rot90cw(Point&lt;T&gt; const&amp; a) {\n  return Point{a.y, -a.x};\n}\n\ntemplate&lt;typename T&gt;\nPoint&lt;T&gt; rot90ccw(Point&lt;T&gt; const&amp; a) {\n  return Point{-a.y, a.x};\n}\n\n// Everything is untested\ntemplate&lt;typename T&gt;\nstruct Line  {\n  Point&lt;T&gt; p1, p2;\n  T a, b, c;\n\n  Line (Point&lt;T&gt; const&amp; p1, Point&lt;T&gt; const&amp; p2) : p1(p1), p2(p2),\n    a(p1.y - p2.y),\n    b(p2.x - p1.x),\n    c(p1^p2) {}\n\n  T eval(Point&lt;T&gt; const&amp; p) const {\n    return a * p.x + b * p.y + c;\n  }\n\n  bool inside(Point&lt;T&gt; const&amp; p) const {\n    return eq(eval(p), T());\n  }\n\n  bool inside_seg(Point&lt;T&gt; const&amp; p) const {\n    return eq(((p1-p) ^ (p2-p)), T())\n           &amp;&amp; ((p1-p) * (p2-p)) &lt;= EPS;\n  }\n};\n\n// Unlikely to work with integral T\ntemplate&lt;typename T&gt;\nvector&lt;Point&lt;T&gt;&gt; inter_line(Line&lt;T&gt; const&amp; l1, Line&lt;T&gt; const&amp; l2) {\n  auto det = l1.a*l2.b - l1.b*l2.a;\n  if (eq(det, T())) return {};\n  auto x = (l1.b*l2.c - l1.c*l2.b)/det;\n  auto y = (l1.c*l2.a - l1.a*l2.c)/det;\n  return {{x,y}};\n}\n\n// Segments with point overlap\ntemplate&lt;typename T&gt;\nvector&lt;Point&lt;T&gt;&gt; inter_seg(Line&lt;T&gt; const&amp; l1, Line&lt;T&gt; const&amp; l2) {\n  auto ans = inter_line(l1, l2);\n  if (ans.empty()) return {};\n  if (!l1.inside_seg(ans.front())) return {};\n  if (!l2.inside_seg(ans.front())) return {};\n  return ans;\n}\n\ntemplate&lt;typename T&gt;\nbool seg_has_inter(Line&lt;T&gt; const&amp; l1, Line&lt;T&gt; const&amp; l2) {\n  if (side(l2.p1, l1.p1, l1.p2) * side(l2.p2, l1.p1, l1.p2) &lt; 0\n   &amp;&amp; side(l1.p1, l2.p1, l2.p2) * side(l1.p2, l2.p1, l2.p2) &lt; 0) return true;\n  if (l1.inside_seg(l2.p1)) return true;\n  if (l1.inside_seg(l2.p2)) return true;\n  if (l2.inside_seg(l1.p1)) return true;\n  if (l2.inside_seg(l1.p2)) return true;\n  return false;\n}\n\ntemplate&lt;typename T&gt;\nT point_line_dist(Point&lt;T&gt; const&amp; p, Line&lt;T&gt; const&amp; l) {\n  return 2 * abs(sarea(p, l.p1, l.p2)) / norm(l.p1-l.p2);\n}\n\ntemplate&lt;typename T&gt;\nT point_seg_dist(Point&lt;T&gt; const&amp; p, Line&lt;T&gt; const&amp; l) {\n  if ((l.p2-l.p1)*(p-l.p1) &lt; 0) return norm(l.p1-p);\n  if ((l.p1-l.p2)*(p-l.p2) &lt; 0) return norm(l.p2-p);\n  return point_line_dist(p, l);\n}\n\ntemplate&lt;typename T&gt;\nT seg_dist(Line&lt;T&gt; const&amp; l1, Line&lt;T&gt; const&amp; l2) {\n  if (seg_has_inter(l1, l2)) return T();\n  return min({point_seg_dist(l1.p1, l2),\n              point_seg_dist(l1.p2, l2),\n              point_seg_dist(l2.p1, l1),\n              point_seg_dist(l2.p2, l1)});\n}\n\ntemplate&lt;typename T&gt;\nstruct Circle {\n  Point&lt;T&gt; c;\n  T r;\n  Circle (Point&lt;T&gt; const&amp; c,  T r) : c(c), r(r) {}\n  bool inside(Point&lt;T&gt; const&amp; a) const {\n    return norm(a-c) &lt;= r + EPS;\n  }\n};\n\ntemplate&lt;typename T&gt;\nvector&lt;Point&lt;T&gt;&gt; inter_circle(Circle&lt;T&gt; const&amp; c1, Circle&lt;T&gt; const&amp; c2) {\n  if (c1.c == c2.c) return {};\n  Point vec = c2.c - c1.c;\n  T d2 = vec * vec;\n  T sum = c1.r + c2.r;\n  T dif = c1.r - c2.r;\n  T p = (d2 + c1.r * c1.r - c2.r * c2.r) / (2 * d2);\n  T h2 = c1.r * c1.r - p * p * d2;\n  if (sum * sum &lt; d2 || dif * dif &gt; d2) return {};\n  Point mid = c1.c + vec*p;\n  Point per = Point(-vec.y, vec.x) * sqrt(max(T(), h2) / d2);\n  if (per == Point&lt;T&gt;()) return {mid};\n  return {mid + per, mid - per};\n}\n\ntemplate&lt;typename T&gt;\nbool inside(Point&lt;T&gt; const&amp; p, Point&lt;T&gt; const&amp; a, Point&lt;T&gt; const&amp; b, Point&lt;T&gt; const&amp; c) {\n  int x = side(p, a, b);\n  int y = side(p, b, c);\n  int z = side(p, c, a);\n  return !((x == 1 or y == 1 or z == 1) and (x==-1 or y == -1 or z == -1));\n}\n\ntemplate&lt;typename T&gt;\nbool inside(Point&lt;T&gt; const&amp; p, vector&lt;Point&lt;T&gt;&gt; const&amp; poly) {\n  int bl = 2, br = (int)size(poly) - 1;\n  while (bl &lt; br) {\n    /* int bm = midpoint(bl, br); */\n    int bm = (bl+br)/2;\n    if (side(p, poly[0], poly[bm]) == 1) bl = bm+1;\n    else br = bm;\n  }\n\n  return inside(p, poly[0], poly[br-1], poly[br]);\n}\n\ntemplate&lt;typename T&gt;\nusing Poly = vector&lt;Point&lt;T&gt;&gt;;\n\ntemplate&lt;typename T&gt;\nT area(Poly&lt;T&gt; const&amp; P) {\n  int N = size(P);\n  T total{};\n  for (int i = 0; i &lt; N; i++) {\n    total += P[i].x * P[(i+1)%N].y;\n    total -= P[i].y * P[(i+1)%N].x;\n  }\n  return abs(total/2);\n}\n//}}}\n</code></pre>"},{"location":"geometry/resources/","title":"Resources","text":"<ul> <li>CGL - Aizu Online Judge - Loads of implementation problems.</li> <li>CSES - Geometry Section</li> </ul>"},{"location":"geometry/resources/#theory","title":"Theory","text":"<p>Counter-clockwise</p> <p>In any context, consider angles are measured in counter-clockwise manner.</p>"},{"location":"geometry/resources/#dot-product","title":"Dot Product","text":""},{"location":"geometry/resources/#math","title":"Math","text":"<ul> <li> <p>\\((a, b) \\cdot (x, y) = ax + by\\)</p> </li> <li> <p>\\(a \\cdot b = \\lvert a\\rvert \\lvert b\\rvert \\cos(\\theta)\\)</p> </li> </ul>"},{"location":"geometry/resources/#properties","title":"Properties","text":"<ol> <li>Can be used for checking acuteness or perpendicularity. Zero means perpendicular. Positive means acute, negative means obtuse.</li> <li>Squared length of a vector: \\(a\\cdot a = {\\lvert a \\rvert}^2\\)</li> <li>Length of projection of \\(a\\) onto \\(b\\): \\(\\dfrac{a \\cdot b}{\\lvert b\\rvert}\\)</li> <li>Angle between vectors: \\(\\arccos\\left(\\dfrac{a\\cdot b}{\\lvert a\\rvert \\lvert b \\rvert}\\right)\\)</li> </ol>"},{"location":"geometry/resources/#extra","title":"Extra","text":"<p>The set of points which have a certain dot product with a given vector is forms a line.</p>"},{"location":"geometry/resources/#cross-product","title":"Cross Product","text":""},{"location":"geometry/resources/#math_1","title":"Math","text":"<ul> <li> <p>\\((a, b) \\times (x, y) = ay - bx\\)</p> </li> <li> <p>\\(a \\times b = \\lvert a \\rvert\\lvert b \\rvert\\sin(\\theta)\\)</p> </li> </ul>"},{"location":"geometry/resources/#properties_1","title":"Properties","text":"<ol> <li> <p>Can be used to check for left, right or collinearity. If \\(a \\times b\\) is zero, the vectors are collienar. Positive means \\(b\\) is to the left of \\(a\\). Negative means \\(b\\) is to the right of \\(a\\).</p> </li> <li> <p>Represents the area of the parallelogram with sides \\(a\\) and \\(b\\). Is pretty much the determinant.</p> </li> <li> <p>\\(a\\times b = -b\\times a\\)</p> </li> <li> <p>\\((a + b)\\times c = a\\times c + b\\times c\\)</p> </li> </ol>"},{"location":"graphs/bfs/","title":"Breadth First Search","text":"<p>Given a graph and a source, returns the distance from the source to all vertices. If the vertex is unreachable, its distance is -1.</p>"},{"location":"graphs/bfs/#code","title":"Code","text":"Breadth First Search<pre><code>// Breadth First Search {{{\nvector&lt;int&gt; bfs(vector&lt;vector&lt;int&gt;&gt; const&amp; G, int source) {\n  vector&lt;int&gt; dist(size(G), -1);\n  queue&lt;int&gt; Q;\n  dist[source] = 0;\n  Q.push(source);\n\n  while (!Q.empty()) {\n    int v = Q.front(); Q.pop();\n    for (auto u : G[v]) {\n      if (dist[u] == -1) {\n        dist[u] = dist[v] + 1;\n        Q.push(u);\n      }\n    }\n  }\n\n  return dist;\n}\n//}}}\n</code></pre>"},{"location":"graphs/block_cut_tree/","title":"Block-Cut Tree","text":""},{"location":"graphs/block_cut_tree/#code","title":"Code","text":"Block-Cut Tree<pre><code>// Block-Cut Tree {{{\nstruct BlockCutTree {\n  int N;\n  vector&lt;vector&lt;int&gt;&gt; const&amp; G;\n\n  stack&lt;pair&lt;int, int&gt;&gt; S;\n  int TIMER = -1;\n  vector&lt;int&gt; pre, low;\n\n  vector&lt;int&gt; art;\n  vector&lt;bool&gt; is_art;\n  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; bcc;\n\n  vector&lt;vector&lt;int&gt;&gt; BCT;\n  vector&lt;int&gt; comp;\n\n  void make_bcc(pair&lt;int, int&gt; until) {\n    bcc.push_back({});\n    pair&lt;int, int&gt; e{-1, -1};\n    while (e != until) {\n      e = S.top(); S.pop();\n      bcc.back().push_back(e);\n    }\n  }\n\n  void dfs(int v, int p) {\n    pre[v] = low[v] = ++TIMER;\n\n    int children = 0;\n    bool low_child = false;\n\n    for (auto u : G[v]) {\n      if (u == p) continue;\n      if (pre[u] == -1) {\n        S.push({v, u});\n        dfs(u, v);\n        children++;\n\n        low[v] = min(low[v], low[u]);\n        if (low[u] &gt;= pre[v]) {\n          low_child = true;\n          make_bcc({v, u});\n        }\n      } else {\n        low[v] = min(low[v], pre[u]);\n      }\n    }\n\n    if ((p == -1 &amp;&amp; children &gt;= 2) || (p != -1 &amp;&amp; low_child))\n      art.push_back(v);\n  }\n\n\n  BlockCutTree(vector&lt;vector&lt;int&gt;&gt; const&amp; G) : G(G), N(size(G)) {\n    pre.assign(N, -1);\n    low.assign(N, -1);\n    for (int i = 0; i &lt; N; i++) {\n      if (pre[i] == -1) {\n        dfs(i, -1);\n      }\n    }\n\n    is_art.resize(N, false);\n    for (auto v : art) is_art[v] = true;\n\n    BCT.resize(N + size(bcc));\n    comp.resize(N);\n    for (int i = 0; i &lt; size(bcc); i++) {\n      for (auto [v, u] : bcc[i]) {\n        if (is_art[v] &amp;&amp; (empty(BCT[v]) || BCT[v].back() != N+i)) BCT[v].push_back(N+i), BCT[N+i].push_back(v);\n        if (is_art[u] &amp;&amp; (empty(BCT[u]) || BCT[u].back() != N+i)) BCT[u].push_back(N+i), BCT[N+i].push_back(u);\n        comp[v] = comp[u] = N+i;\n      }\n    }\n\n    for (auto v : art) comp[v] = v;\n  }\n};\n//}}}\n</code></pre>"},{"location":"graphs/eulerian_cycle/","title":"Eulerian Cycle","text":"<p>Given a graph represented as a list of edges, returns a path through these edges that goes through each edge exactly once.</p> <p>Returns a pair where the first element is whether there is an eulerian cycle, and the second one is a vector of indices of the vertices in the cycle.</p>"},{"location":"graphs/eulerian_cycle/#code","title":"Code","text":"Eulerian Cycle<pre><code>// Eulerian Cycle {{{\npair&lt;bool, vector&lt;int&gt;&gt; eulerian_cycle(int N, vector&lt;pair&lt;int, int&gt;&gt; const&amp; E) {\n  int M = size(E);\n\n  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; G(N);\n  for (int i = 0; i &lt; M; i++) {\n    auto [v, u] = E[i];\n    G[v].push_back({u, i});\n    G[u].push_back({v, i});\n  }\n\n  for (int i = 0; i &lt; N; i++)\n    if (size(G[i]) % 2)\n      return {false, {}};\n\n  vector&lt;int&gt; path;\n  vector&lt;bool&gt; seen(M);\n\n  auto dfs = [&amp;](auto &amp;&amp;F, int v) -&gt; void {\n    while (!G[v].empty()) {\n      auto [u, idx] = G[v].back();\n      G[v].pop_back();\n      if (seen[idx]) continue;\n      seen[idx] = true;\n      F(F, u);\n    }\n    path.push_back(v);\n  };\n  dfs(dfs, 0);\n\n  if (size(path) != M+1) return {false, {}};\n\n  reverse(begin(path), end(path));\n  return {true, path};\n}\n//}}}\n</code></pre>"},{"location":"graphs/flow/","title":"Flow","text":""},{"location":"graphs/flow/#dinitz","title":"Dinitz","text":"<p>This is based on the implementation on cp-algorithms. But in my opinion this one is much more organized.</p> Dinitz<pre><code>// Dinitz {{{\nstruct Dinitz {\n  struct Edge {\n    int v, u, cap, flow=0;\n    Edge (int v, int u, int cap) : v(v), u(u), cap(cap) {}\n  };\n\n  vector&lt;Edge&gt; edges;\n  vector&lt;vector&lt;int&gt;&gt; adj;\n\n  int n, s, t;\n  Dinitz(int n, int s, int t) : n(n), s(s), t(t) {\n    adj.resize(n);\n  }\n\n  void add_edge(int v, int u, int cap) {\n    edges.emplace_back(v, u, cap);\n    adj[v].push_back(edges.size()-1);\n    edges.emplace_back(u, v, 0);\n    adj[u].push_back(edges.size()-1);\n  }\n\n  vector&lt;int&gt; level;\n  bool bfs() {\n    queue&lt;int&gt; Q;\n    level.assign(n, -1);\n    level[s] = 0;\n    Q.push(s);\n    while (!Q.empty()) {\n      int v = Q.front(); Q.pop();\n      for (auto eid : adj[v]) {\n        auto e = edges[eid];\n        if (e.cap - e.flow &lt;= 0) continue;\n        if (level[e.u] != -1) continue;\n        level[e.u] = level[v] + 1;\n        Q.push(e.u);\n      }\n    }\n    return level[t] != -1;\n  }\n\n  vector&lt;int&gt; ptr;\n  int dfs(int v, int f) {\n    if (f == 0 || v == t) return f;\n    for (int &amp;cid = ptr[v]; cid &lt; adj[v].size(); cid++) {\n      int eid = adj[v][cid];\n      auto &amp;e = edges[eid];\n      if (e.cap - e.flow &lt;= 0) continue;\n      if (level[e.u] != level[e.v] + 1) continue;\n      int newf = dfs(e.u, min(f, e.cap-e.flow));\n      if (newf == 0) continue;\n      e.flow += newf;\n      edges[eid^1].flow -= newf;\n      return newf;\n    }\n    return 0;\n  }\n\n  int flow() {\n    int f = 0;\n    while (bfs()) {\n      ptr.assign(n, 0);\n      while (int newf = dfs(s, INF))\n        f += newf;\n    }\n    return f;\n  }\n}; //}}}\n</code></pre>"},{"location":"graphs/flow/#dinitz-min-cost","title":"Dinitz Min-Cost","text":"<p>The same as above, but allows you to set a cost per flow unit for each edge. This is lightly based on the article on cp-algorithms.</p> <p>It uses SPFA instead of Bellman-Ford since it is usually much faster.</p> Dinitz Min-Cost<pre><code>// Dinitz Min Cost {{{\nconst int INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Dinitz {\n  struct Edge {\n    int v, u, cap, flow=0, cost;\n    Edge(int v, int u, int cap, int cost) : v(v), u(u), cap(cap), cost(cost) {}\n  };\n\n  int n, s, t;\n  Dinitz(int n, int s, int t) : n(n), s(s), t(t) {\n    adj.resize(n);\n  }\n\n  V&lt;Edge&gt; edges;\n  V&lt;V&lt;int&gt;&gt; adj;\n  void add_edge(int v, int u, int cap, int cost) {\n    edges.emplace_back(v, u, cap, cost);\n    adj[v].pb(sz(edges)-1);\n    edges.emplace_back(u, v, 0, -cost);\n    adj[u].pb(sz(edges)-1);\n  }\n\n  V&lt;int&gt; dist;\n  bool spfa() {\n    dist.assign(n, INF);\n\n    queue&lt;int&gt; Q;\n    V&lt;bool&gt; inqueue(n, false);\n\n    dist[s] = 0;\n    Q.push(s);\n    inqueue[s] = true;\n\n    V&lt;int&gt; cnt(n);\n\n    while (!Q.empty()) {\n      int v = Q.front(); Q.pop();\n      inqueue[v] = false;\n\n      for (auto eid : adj[v]) {\n        auto const&amp; e = edges[eid];\n        if (e.cap - e.flow &lt;= 0) continue;\n        if (dist[e.u] &gt; dist[e.v] + e.cost) {\n          dist[e.u] = dist[e.v] + e.cost;\n          if (!inqueue[e.u]) {\n            Q.push(e.u);\n            inqueue[e.u] = true;\n          }\n        }\n      }\n    }\n\n    return dist[t] != INF;\n  }\n\n  int cost = 0;\n  V&lt;int&gt; ptr;\n  int dfs(int v, int f) {\n    if (v == t || f == 0) return f;\n    for (auto &amp;cid = ptr[v]; cid &lt; sz(adj[v]);) {\n      auto eid = adj[v][cid];\n      auto &amp;e = edges[eid];\n      cid++;\n      if (e.cap - e.flow &lt;= 0) continue;\n      if (dist[e.v] + e.cost != dist[e.u]) continue;\n      int newf = dfs(e.u, min(f, e.cap-e.flow));\n      if (newf == 0) continue;\n      e.flow += newf;\n      edges[eid^1].flow -= newf;\n      cost += e.cost * newf;\n      return newf;\n    }\n    return 0;\n  }\n\n  int total_flow = 0;\n  int flow() {\n    while (spfa()) {\n      ptr.assign(n, 0);\n      while (int newf = dfs(s, INF))\n        total_flow += newf;\n    }\n    return total_flow;\n  }\n};\n//}}}\n</code></pre>"},{"location":"graphs/kosaraju/","title":"Kosaraju","text":"<p>Can be used to find strongly connected components.</p>"},{"location":"graphs/kosaraju/#code","title":"Code","text":"Kosaraju<pre><code>// Kosaraju {{{\nstruct Kosaraju {\n  int N;\n  vector&lt;vector&lt;int&gt;&gt; const&amp; G;\n  vector&lt;vector&lt;int&gt;&gt; Ginv;\n  vector&lt;bool&gt; vis;\n  stack&lt;int&gt; S;\n\n  vector&lt;int&gt; comp;\n  vector&lt;vector&lt;int&gt;&gt; comps;\n\n  Kosaraju(vector&lt;vector&lt;int&gt;&gt; const&amp; G)\n    : N(size(G)), G(G), Ginv(N), vis(N), comp(N, -1) {\n    for (int i = 0; i &lt; N; i++) {\n      for (auto u : G[i]) {\n        Ginv[u].push_back(i);\n      }\n    }\n\n    for (int i = 0; i &lt; N; i++) if (!vis[i]) dfs(i);\n\n    fill(begin(vis), end(vis), false);\n    int cc = 0;\n    while (!S.empty()) {\n      int v = S.top();\n      S.pop();\n      if (!vis[v]) {\n        comps.push_back({});\n        scc(v, cc++);\n      }\n    }\n  }\n\n  void dfs(int v) {\n    vis[v] = true;\n    for (auto u : G[v]) if (!vis[u]) dfs(u);\n    S.push(v);\n  }\n\n  void scc(int v, int c) {\n    vis[v] = true;\n    comp[v] = c;\n    comps.back().push_back(v);\n    for (auto u : Ginv[v]) if (!vis[u]) scc(u, c);\n  }\n};\n// }}}\n</code></pre>"},{"location":"graphs/lca/","title":"Lowest Common Ancestor","text":"<p>Given a tree, offers the following functions (source is smallest vertex in the component):</p> <ul> <li><code>is_ancestor(v, u)</code> - whether v is an ancestor of u in the tree</li> <li><code>lca(v, u)</code> - lowest common ancestor of v and u</li> <li><code>dist(v, u)</code> - shortest distance between v and u</li> </ul> <p>If LCA or dist are called with vertices from different components, you'll probably get a runtime error.</p>"},{"location":"graphs/lca/#code","title":"Code","text":"Lowest Common Ancestor<pre><code>// Lowest Common Ancestor {{{\nstruct LCA {\n  const int LOG = 22;\n\n  int N;\n  vector&lt;vector&lt;int&gt;&gt; const&amp; G;\n\n  int TIMER = -1;\n  vector&lt;int&gt; pre, pos, dep;\n  vector&lt;vector&lt;int&gt;&gt; parent;\n\n  void dfs(int v, int p) {\n    parent[v][0] = p;\n    for (int b = 1; b &lt; LOG; b++) {\n      parent[v][b] = parent[parent[v][b-1]][b-1];\n    }\n\n    pre[v] = ++TIMER;\n    for (auto u : G[v]) {\n      if (u == p) continue;\n      dep[u] = dep[v] + 1;\n      dfs(u, v);\n    }\n    pos[v] = TIMER;\n  }\n\n  bool is_ancestor(int anc, int child) {\n    return pre[anc] &lt;= pre[child] &amp;&amp; pos[child] &lt;= pos[anc];\n  }\n\n  int lca(int v, int u) {\n    if (is_ancestor(v, u)) return v;\n    if (is_ancestor(u, v)) return u;\n\n    for (int b = LOG-1; b &gt;= 0; b--) {\n      int nv = parent[v][b];\n      if (!is_ancestor(nv, u)) v = nv;\n    }\n    v = parent[v][0];\n    return v;\n  }\n\n  int dist(int v, int u) {\n    int l = lca(v, u);\n    int dist = dep[v] + dep[u] - 2*dep[l];\n    return dist;\n  }\n\n  LCA (vector&lt;vector&lt;int&gt;&gt; const&amp; G) : G(G), N(size(G)) {\n    pre.assign(N, -1);\n    pos.assign(N, -1);\n    dep.assign(N, 0);\n    parent.resize(N, vector&lt;int&gt;(LOG));\n    for (int i = 0; i &lt; N; i++) {\n      if (pre[i] == -1) {\n        dfs(i, i);\n      }\n    }\n  }\n};\n//}}}\n</code></pre>"},{"location":"graphs/tour/","title":"Euler Tour","text":"<p>Performs an euler tour in a graph, obtaining <code>pre</code>, <code>pos</code>, <code>dep</code> and <code>who</code>.</p>"},{"location":"graphs/tour/#code","title":"Code","text":"Euler Tour<pre><code>// Euler Tour {{{\nstruct Tour {\n  int source;\n  vector&lt;vector&lt;int&gt;&gt; const&amp; G;\n\n  int TIMER = -1;\n  vector&lt;int&gt; pre, pos, dep, who;\n\n  Tour (vector&lt;vector&lt;int&gt;&gt; const&amp; G, int source) : G(G), source(source) {\n    int N = size(G);\n    pre.assign(N, -1);\n    pos.assign(N, -1);\n    dep.assign(N, -1);\n    who.assign(N, -1);\n    dep[source] = 0;\n    walk(source);\n  }\n\n  void walk(int v) {\n    pre[v] = ++TIMER;\n    who[pre[v]] = v;\n    for (auto u : G[v]) {\n      if (pre[u] == -1) {\n        dep[u] = dep[v] + 1;\n        walk(u);\n      }\n    }\n    pos[v] = TIMER;\n  }\n};\n//}}}\n</code></pre>"},{"location":"graphs/two_sat/","title":"2-SAT","text":"<p>Give a series of logical statements and it tells you if they're consistent and gives you a solution.</p>"},{"location":"graphs/two_sat/#code","title":"Code","text":"2-SAT<pre><code>// TwoSat {{{\nstruct TwoSat {\n  int N;\n  vector&lt;vector&lt;int&gt;&gt; G;\n  TwoSat(int N) : N(N), G(2*N) {}\n\n  int neg(int u) { return u + ((u &lt; N) ? N : -N); }\n  void add_or(int v, int u) {\n    G[neg(v)].push_back(u);\n    G[neg(u)].push_back(v);\n  }\n  void add_diff(int v, int u) {\n    G[v].push_back(neg(u));\n    G[neg(v)].push_back(u);\n    G[u].push_back(neg(v));\n    G[neg(u)].push_back(v);\n  }\n  void add_impl(int v, int u) {\n    G[v].push_back(u);\n    G[neg(u)].push_back(neg(v));\n  }\n  void add_same(int v, int u) {\n    G[v].push_back(u);\n    G[neg(v)].push_back(neg(u));\n    G[u].push_back(v);\n    G[neg(u)].push_back(neg(v));\n  }\n\n  // Assumes Kosaraju returns components in topological ordering v -&gt; u implies scc[v] &lt;= scc[u]\n  pair&lt;bool, vector&lt;bool&gt;&gt; solve() {\n    vector&lt;bool&gt; res(N);\n    auto scc = Kosaraju(G).comp;\n    for (int i = 0; i &lt; N; i++) {\n      if (scc[i] == scc[neg(i)]) return {false, {}};\n      res[i] = scc[i] &lt; scc[neg(i)];\n    }\n    return {true, res};\n  }\n};\n//}}}\n</code></pre>"},{"location":"math/baby_steps/","title":"Baby Steps, Giant Steps","text":""},{"location":"math/baby_steps/#code","title":"Code","text":"Baby Steps, Giant Steps<pre><code>// Baby Steps, Giant Steps {{{\n// https://cp-algorithms.com/algebra/discrete-log.html\n// Returns minimum x for which a ^ x % m = b % m, a and m are coprime.\nint babysteps(int a, int b, int m) {\n  a %= m, b %= m;\n  int n = sqrt(m) + 1;\n\n  int an = 1;\n  for (int i = 0; i &lt; n; ++i)\n    an = (an * 1ll * a) % m;\n\n  unordered_map&lt;int, int&gt; vals;\n  for (int q = 0, cur = b; q &lt;= n; ++q) {\n    vals[cur] = q;\n    cur = (cur * 1ll * a) % m;\n  }\n\n  for (int p = 1, cur = 1; p &lt;= n; ++p) {\n    cur = (cur * 1ll * an) % m;\n    if (vals.count(cur)) {\n      int ans = n * p - vals[cur];\n      return ans;\n    }\n  }\n  return -1;\n}\n//}}}\n</code></pre>"},{"location":"math/bitmasks/","title":"Bitmasks","text":""},{"location":"math/bitmasks/#iterating-through-all-subsmasks","title":"Iterating through all subsmasks","text":"<p>This technique can be found on this article.</p> Iterating through all submasks of m<pre><code>// doesn't go through 0\nfor (int s=m; s; s=(s-1)&amp;m) {}\n// goes through 0\nfor (int s=m;  ; s=(s-1)&amp;m) {\n    if (s == 0) break;\n}\n</code></pre>"},{"location":"math/bitmasks/#number-of-supermasks","title":"Number of supermasks","text":"<p>Given a list of masks, count for each possible mask how many masks it is a submask of. This looks a lot like SOS DP?</p> Number of supermasks<pre><code>const int MAXB = 20;\nvector&lt;int&gt; amount(1 &lt;&lt; MAXB);\n\nfor (int b = MAXB-1; b &gt;= 0; b--) {\n  for (int j = 0; j &lt; 1 &lt;&lt; MAXB; j++) {\n    if (j &amp; (1 &lt;&lt; b)) {\n      amount[j ^ (1 &lt;&lt; b)] += amount[j];\n    }\n  }\n}\n</code></pre>"},{"location":"math/bitmasks/#problems","title":"Problems","text":"<ul> <li>(CF1523-B) Love-Hate</li> <li>(CF449-D) Jzzhu and Numbers</li> </ul>"},{"location":"math/combinatorics/","title":"Combinatorics","text":""},{"location":"math/combinatorics/#implementation","title":"Implementation","text":"<p>This implementation is based on the one by WeakestTopology, which is available on his Github repository.</p> Combinatorics<pre><code>// Combinatorics {{{\ntemplate &lt;unsigned P&gt;\nstruct Combinatorics {\n  vector&lt;Z&lt;P&gt;&gt; fact, ifact;\n\n  explicit Combinatorics(int N) : fact(N), ifact(N) {\n    fact[0] = 1;\n    for (int i = 1; i &lt; N; i++) fact[i] = fact[i-1] * i;\n    ifact[N-1] = 1 / fact[N-1];\n    for (int i = N-1; i-1 &gt;= 0; i--) ifact[i-1] = ifact[i] * i;\n  }\n\n  Z&lt;P&gt; C(int n, int k) const {\n    return k &lt; 0 || n &lt; k ?  0 : fact[n] * ifact[k] * ifact[n-k];\n  }\n\n  Z&lt;P&gt; S(int n, int k) const {\n    return k == 0 ? n == 0 : C(n + k - 1, k - 1);\n  }\n};\n//}}}\n</code></pre>"},{"location":"math/ext_gcd/","title":"Linear Diophantine Equations","text":"<p>If you want to understand everything, read this [cp-algorithms] - Linear Diophantine Equations. I think this code is much better. It's possible to do it iteratively, but that's probably unnecessary.</p>"},{"location":"math/ext_gcd/#extended-gcd","title":"Extended GCD","text":"<p>Given two integers \\(a\\) and \\(b\\), returns their gcd and two coefficients \\(x\\) and \\(y\\) such that \\(ax + by = g\\).</p>"},{"location":"math/ext_gcd/#linear-diophantine-equations_1","title":"Linear Diophantine Equations","text":"<p>Given three integers \\(a\\), \\(b\\), \\(c\\), returns whether it is possible to get \\(x\\) and \\(y\\) such that \\(ax + by = c\\), as well as \\(x\\) and \\(y\\) if possible.</p> Extended GCD<pre><code>// Extended GCD {{{\ntuple&lt;int, int, int&gt; ext_gcd(int a, int b) {\n  if (b == 0) return {a, 1, 0};\n  auto [g, x, y] = ext_gcd(b, a%b);\n  return {g, y, x - (a/b) * y};\n}\n\ntuple&lt;bool, int, int&gt; dio(int a, int b, int c) {\n  auto [g, x, y] = ext_gcd(a, b);\n  if (c % g) return {false, -1, -1};\n  return {true, x * (c/g), y * (c/g)};\n}\n//}}}\n</code></pre>"},{"location":"math/floor_sum/","title":"Floor Sum","text":"<p>Returns the sum</p> \\[ \\sum_{i=0}^{n-1} \\Bigl\\lfloor \\frac{a\\times i + b}{m} \\Bigr\\rfloor \\] <p>in \\(O(\\log m)\\) complexity.</p>"},{"location":"math/floor_sum/#code","title":"Code","text":"<p>My implementation was stolen straight from AtCoder Library.</p> Floor Sum<pre><code>// Floor Sum {{{\n// sum of floor[i=0...n-1]((a*i+b)/m)\nunsigned long long __floor_sum_unsigned(unsigned long long n,\n                                      unsigned long long m,\n                                      unsigned long long a,\n                                      unsigned long long b) {\n  unsigned long long ans = 0;\n  while (true) {\n    if (a &gt;= m) {\n      ans += n * (n - 1) / 2 * (a / m);\n      a %= m;\n    }\n    if (b &gt;= m) {\n      ans += n * (b / m);\n      b %= m;\n    }\n\n    unsigned long long y_max = a * n + b;\n    if (y_max &lt; m) break;\n    // y_max &lt; m * (n + 1)\n    // floor(y_max / m) &lt;= n\n    n = (unsigned long long)(y_max / m);\n    b = (unsigned long long)(y_max % m);\n    swap(m, a);\n  }\n  return ans;\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n  unsigned long long ans = 0;\n  if (a &lt; 0) {\n    unsigned long long a2 = (a%m+m)%m;\n    ans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m);\n    a = a2;\n  }\n  if (b &lt; 0) {\n    unsigned long long b2 = (a%m+m)%m;\n    ans -= 1ULL * n * ((b2 - b) / m);\n    b = b2;\n  }\n  return ans + __floor_sum_unsigned(n, m, a, b);\n}\n//}}}\n</code></pre>"},{"location":"math/xor_basis/","title":"XOR-Basis","text":""},{"location":"math/xor_basis/#implementation","title":"Implementation","text":"XOR Basis<pre><code>// XOR Basis {{{\nstruct Basis {\n  vector&lt;int&gt; B;\n  int reduce(int x) {\n    for (auto b : B) x = min(x, x^b);\n    return x;\n  }\n  void insert(int x) {\n    int r = reduce(x);\n    if (r) B.push_back(r);\n  }\n};\n//}}}\n</code></pre>"},{"location":"math/xor_basis/#explanation","title":"Explanation","text":"<p>On USACO Guide you can find a great presentation by Benq, as well as various problems.</p>"},{"location":"math/z_p/","title":"Modular Arithmetic","text":""},{"location":"math/z_p/#implementation","title":"Implementation","text":"<p>This implementation is heavily based on the one by WeakestTopology, which is available on his Github repository.</p> Modular Arithmetic<pre><code>// Z_P (Modular Arithmetic) {{{\ntemplate &lt;unsigned P&gt;\nstruct Z {\n  unsigned value;\n\n  constexpr Z() : value(0) {}\n\n  template&lt;typename T, typename = enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;&gt;\n  constexpr Z(T a) : value((((long long)a % P) + P) % P) {}\n\n  Z&amp; operator+=(Z rhs) {\n    value += rhs.value;\n    if (value &gt;= P) value -= P;\n    return *this;\n  }\n\n  Z&amp; operator-=(Z rhs) {\n    value += P - rhs.value;\n    if (value &gt;= P) value -= P;\n    return *this;\n  }\n\n  Z&amp; operator*=(Z rhs) {\n    value = (unsigned long long)value * rhs.value % P;\n    return *this;\n  }\n\n  Z&amp; operator/=(Z rhs) { return *this *= pow(rhs, -1); }\n\n  Z operator+() const { return *this; }\n\n  Z operator-() const { return Z() - *this; }\n\n  bool operator==(Z rhs) const { return value == rhs.value; }\n\n  bool operator!=(Z rhs) const { return value != rhs.value; }\n\n  friend Z operator+(Z lhs, Z rhs) { return lhs += rhs; }\n\n  friend Z operator-(Z lhs, Z rhs) { return lhs -= rhs; }\n\n  friend Z operator*(Z lhs, Z rhs) { return lhs *= rhs; }\n\n  friend Z operator/(Z lhs, Z rhs) { return lhs /= rhs; }\n\n  friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Z a) { return out &lt;&lt; a.value; }\n\n  friend istream&amp; operator&gt;&gt;(istream&amp; in, Z&amp; a) {\n    long long x;\n    in &gt;&gt; x;\n    a = Z(x);\n    return in;\n  }\n};\n\ntemplate&lt;unsigned P&gt;\nZ&lt;P&gt; pow(Z&lt;P&gt; x, long long p) {\n  if (x == 0) {\n    return p == 0 ? 1 : 0;\n  }\n  p %= P -1;\n  if (p &lt; 0) p += P-1;\n  Z&lt;P&gt; res = 1;\n  while (p) {\n    if (p &amp; 1) {\n      res *= x;\n    }\n    x *= x;\n    p &gt;&gt;= 1;\n  }\n  return res;\n}\n//}}}\n</code></pre>"},{"location":"meta/checklist/","title":"Checklist","text":""},{"location":"meta/checklist/#thinking-about-solution","title":"Thinking about solution","text":"<ul> <li>Immediately play with the sample cases, you may have understood the problem wrong</li> <li>Pay close attention to the constraints</li> <li>Always consider doing Binary Search on the answer</li> </ul>"},{"location":"meta/checklist/#before-submitting","title":"Before Submitting","text":"<ul> <li>Even if the test cases pass, make sure your code is at least doing something</li> <li>If the test cases are too simple, come up with a couple extra ones</li> <li>Check if constants are big enough</li> <li>Check time and memory limits</li> <li>Submit the right file</li> </ul>"},{"location":"meta/checklist/#general","title":"General","text":"<ul> <li><code>#define int long long</code></li> <li>Fast IO</li> <li>Be very careful when copy pasting, check you've changed everything that needs changing</li> <li>Be wary of special cases, and when you do define one, be very sure you've correctly identified the full extent of their implications</li> </ul>"},{"location":"meta/checklist/#stl","title":"STL","text":"<ul> <li>Don't call .back(), .front(), .top() on empty containers</li> <li>Don't change a container as you iterate through it (Even accessing a map may change it)</li> <li>Always make sure your iterators are valid</li> </ul>"},{"location":"meta/checklist/#graphs","title":"Graphs","text":"<ul> <li>Add edges both ways if the graph is bidirectional</li> <li>On problems where you remove stuff, just do it backwards.</li> </ul>"},{"location":"meta/checklist/#beecrowduva","title":"Beecrowd/UVa \ud83e\udd2e","text":"<ul> <li>Don't put space at the end of output</li> <li>Check if there are multiple testcases</li> </ul>"},{"location":"meta/checklist/#dp","title":"DP","text":"<ul> <li>Try to invert the order of the states - sometimes the problem becomes much easier</li> <li>Can you use D&amp;C DP?</li> <li>Can you use Convex Hull Trick?</li> </ul>"},{"location":"meta/commands/","title":"Commands","text":""},{"location":"meta/commands/#compiling","title":"Compiling","text":"<p>Sanitizers are very useful. Always use them with <code>-g3</code>, which enables debug information. It makes it so you can instantly know which line is causing your runtime error.</p> <pre><code>g++ -Wall -Wextra -Wconversion -g3 -O3 -fsanitize=address,undefined a.cpp -o a\n</code></pre>"},{"location":"meta/commands/#valgrind","title":"Valgrind","text":"<pre><code>valgrind --tool=cachegrind ./a &lt; a.txt\nkcachegring kcachegrind cachegrind.out.XXXX\n</code></pre>"},{"location":"meta/commands/#hashing","title":"Hashing","text":"<p>Hashes a file, ignoring all whitespace and comments. Use for verifying that code was correctly typed.</p> <pre><code>cpp -dD -P -fpreprocessed | tr -d '[:space:]'| md5sum | cut -c-6\n</code></pre>"},{"location":"meta/gyms/","title":"Gyms","text":""},{"location":"meta/gyms/#2023-05-26","title":"2023-05-26","text":"<ul> <li>Contest: 2020-2021 ACM-ICPC Latin American Regional Programming Contest</li> <li>Location: LINF 1 - UnB</li> <li>Duration: 4h</li> <li>Team: cebolinha, EYZ, Vilsu</li> <li>Expectation: We should try to solve at least 6 problems but 7 or 8 would be good</li> <li>Result: Solved 8 problems, if we had 2 or 3 extra minutes we would have solved J as well</li> </ul>"},{"location":"meta/gyms/#upsolving","title":"Upsolving","text":"<ul> <li> A. Almost Origami</li> <li> G. Game of Slots</li> <li> I. Impenetrable Wall</li> <li> M. May I add a Letter?</li> </ul>"},{"location":"meta/gyms/#2023-06-23","title":"2023-06-23","text":"<ul> <li>Contest: Brazilian ICPC Summer School 2017, Contest 2017-01-31</li> <li>Location: LINF 1 - UnB</li> <li>Duration: 5h (did about 4h)</li> <li>Team: cebolinha, EYZ, Vilsu</li> </ul>"},{"location":"meta/gyms/#upsolving_1","title":"Upsolving","text":"<ul> <li> B. Prefix-function to z-function</li> <li> F. Fibonacci Strings</li> <li> N. Sum and Product</li> </ul>"},{"location":"meta/gyms/#2023-06-30","title":"2023-06-30","text":"<ul> <li>Contest: La Salle-Pui Ching Programming Challenge \u57f9\u6b63\u5587\u6c99\u7de8\u7a0b\u6311\u6230\u8cfd 2021</li> <li>Location: Little Room - CIC</li> <li>Duration 5h (did 4h)</li> <li>Team: cebolinha, EYZ, Vilsu</li> </ul>"},{"location":"meta/gyms/#upsolving_2","title":"Upsolving","text":"<ul> <li> A. Allowance Exhaustion</li> <li> F. Furthest Travel - Compressed Matrix Exponentiation (?)</li> <li> G. Gold Medal Bout - Really annoying implementation problem</li> <li> H. How to Get Rice</li> <li> K. Kario Mart</li> </ul>"},{"location":"meta/gyms/#2023-07-07","title":"2023-07-07","text":"<ul> <li>Contest: 2023-2024 ICPC German Collegiate Programming Contest (GCPC 2023)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha, EYZ, Vilsu</li> <li>Result: solved 9 problems. Unnecessarily wasted a lot of time on B and K.</li> </ul>"},{"location":"meta/gyms/#upsolving_3","title":"Upsolving","text":"<ul> <li> A. Adolescent Architecture</li> <li> H. Highway Combinatorics</li> <li> F. Freestyle Masonry</li> <li> J. Japanese Lottery</li> </ul>"},{"location":"meta/gyms/#2023-07-13","title":"2023-07-13","text":"<ul> <li>Contest: UTPC Contest 09-17-21 Div. 1 (Advanced)</li> <li>Location: Remote</li> <li>Duration: 2h</li> <li>Team: cebolinha</li> <li>Result: Solved 9/11, didn't even read M. Wasted a lot of time on silly coding mistakes on J and L.</li> </ul>"},{"location":"meta/gyms/#upsolving_4","title":"Upsolving","text":"<ul> <li> K. Alloy Factory</li> <li> M. Ominous Chess</li> </ul>"},{"location":"meta/gyms/#2023-07-14","title":"2023-07-14","text":"<ul> <li>Contest: UTPC Contest 03-24-23 Div. 1 (Advanced)</li> <li>Location: Remote</li> <li>Duration: 2h</li> <li>Team: cebolinha, EYZ</li> <li>Result: Solved 6/8. Didn't even read J, tried G for some time. Not bad.</li> </ul>"},{"location":"meta/gyms/#upsolving_5","title":"Upsolving","text":"<ul> <li> G. Path to Pluto</li> <li> J. Rocket Fuel</li> </ul>"},{"location":"meta/gyms/#2023-09-23","title":"2023-09-23","text":"<ul> <li>Contest: 2023 Argentinian Programming Tournament (TAP)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha, EYZ, vilsu</li> <li>Result: Solved 13/14. Pretty great.</li> </ul>"},{"location":"meta/gyms/#upsolving_6","title":"Upsolving","text":"<ul> <li> K. Kitties</li> </ul>"},{"location":"meta/gyms/#2023-10-01","title":"2023-10-01","text":"<ul> <li>Contest: 2017-2018 Northwestern European Regional Contest (NWERC 2017)</li> <li>Location: quirino's house</li> <li>Duration: 5h</li> <li>Team: cebolinha</li> <li>Result: Solved 7/11. Not bad. F is a nice use of RangeSet. G is a nice geometry problem. Wasted too much time on I because of a line I forgot to delete.</li> </ul>"},{"location":"meta/gyms/#upsolving_7","title":"Upsolving","text":"<ul> <li>[  ] A. Ascending Photo</li> <li>[  ] C. Connect The Dots</li> <li>[  ] E. English Restaurant</li> <li>[  ] J. Juggling Troupe</li> </ul>"},{"location":"meta/gyms/#future-gyms","title":"Future Gyms","text":"<ul> <li>Universal Cup. Stage 4: Ukraine</li> <li>Universal Cup. Stage 9: Qingdao</li> <li>Universal Cup. Stage 14: Ranoa</li> <li>2022 ICPC Southeastern Europe</li> <li>The 2021 ICPC Asia Nanjing</li> <li>NWERC 2021</li> <li>NWERC 2020</li> <li>NWERC 2019</li> <li>NWERC 2018</li> </ul>"},{"location":"meta/rttr/","title":"RTTR","text":""},{"location":"meta/rttr/#about","title":"About","text":""},{"location":"meta/rttr/#theory","title":"Theory","text":"<p>Rounds will be held on the Vjudge Group.</p> <p>After doing 100 rounds of these, you will get the Grandmaster on Codeforces. It is 100% guaranteed, trust me.</p> <p>I'll try to do these often and post little hints and solutions afterwards.</p>"},{"location":"meta/rttr/#rttr-1","title":"RTTR #1","text":"<p>Result:</p> <ul> <li> Fib-Tree</li> <li> Are You Fired?</li> <li> DeadLee</li> </ul> <p>Didn't solve the first problem because of a silly implementation mistake. (Granted I did overcomplicated a little).</p> <p>Overall really great problems, highly recommend solving all of them.</p>"},{"location":"meta/rttr/#fib-tree","title":"Fib-Tree","text":"Hint 1 <p>For a given Fibonacci number, there is a single way of decomposing it into smaller Fibonacci numbers.</p> Hint 2 <p>For a given tree of fibonacci size, there are at most two ways of decomposing it into smaller trees of fibonacci size.</p> Hint 2.1 <p>It doesn't matter which of the ways you pick.</p> Solution <ul> <li>Create some function <code>fibtree(v)</code> which will return a bool if the tree that contains v is a Fib-Tree.</li> <li>Root the tree in v and get all the subtree sizes.</li> <li>Iterate through the tree until you find someone with size \\(F_{i-1}\\) or \\(F_{i-2}\\).</li> <li>Remove the edge connecting that vertex to its parent.<ul> <li>This is possible by making G a <code>vector&lt;set&lt;int&gt;&gt;</code></li> </ul> </li> <li>When you get to a subtree of size at most 3, return true.</li> </ul> Thoughts <ul> <li>Really great problem, but it pretty easy to guess the solution without understanding why it works.</li> <li>I ended up using the trees' centroids, which wasn't too bad but unnecessary.</li> <li>Silly implementation mistake, was returning too eagerly in the <code>get_need</code> function.</li> </ul>"},{"location":"meta/rttr/#are-you-fired","title":"Are You Fired?","text":"Hint 1 <p>If a solution with some length works. A solution with double that length also works.</p> Hint 2 <p>That means that there is a solution with length at least \\(N/2+1\\).</p> Hint 3 <p>That makes the case \\(X &gt; 0\\) really easy.</p> Hint 2.1 <p>Just pick N. Check if that works.</p> Solution <ul> <li>We're down to the case \\(X \\leq 0\\) and we know the length is at least \\(N/2+1\\).</li> <li>Document for each position from the first half how long the range starting at it can be.</li> <li>The length must be at least \\(N/2+1\\). As the range grows the sum decreases, so it is a prefix.</li> <li>Therefore we can binary search for that.</li> <li>To check if some length len works overall,   check if all the indices where ranges would be starting can handle ranges that big.</li> </ul> Thoughts <ul> <li>Did this problem pretty quickly.</li> <li>Did the right choice of dividing it into cases and analysing.</li> </ul>"},{"location":"meta/rttr/#deadlee","title":"DeadLee","text":"Hint 1 <p>Work with the concept of having \"enough\" of a given food. Count how many people want each food. You have enough of it if you have more of it than people want.</p> Solution <ul> <li>What can you do if you have enough of some food \\(f\\)?<ul> <li>Give it to everyone who wants it, then remove these people.</li> <li>By \"remove\" I mean put them in the back of the order and make them \"not want\" the rest of the food.</li> <li>You can do that by keeping a <code>vector&lt;set&lt;int&gt;&gt;</code> with the people that want each food.</li> </ul> </li> <li>If by removing people you now have enough of some other food, put that food on the queue and repeat the process.</li> <li>It is kinda like a BFS</li> <li>Implementation for reference</li> </ul> Thoughts <ul> <li>Really nice problem but also quite easy. Not sure why it is rated 2400.</li> <li>Once you create the concept of having \"enough\" of some food the solution flows pretty naturally.</li> </ul>"},{"location":"meta/vedj/","title":"Virtual Every Day June","text":"<p>Rating changes calculated using Codeforces Visualizer.</p> <p>It is kinda silly to calculate Div. 2 rating changes for ratings over 2100, but I don't care.</p>"},{"location":"meta/vedj/#day-1","title":"Day 1","text":"<p>Educational Codeforces Round 134</p> <ul> <li>cebolinha: \\(2176 - 88 = 2088\\)</li> <li>EYZ: \\(1595 - 60 = 1535\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino","title":"Upsolving Quirino","text":"<ul> <li> E - Prefix Function Queries</li> <li> F - Matching Reduction</li> </ul>"},{"location":"meta/vedj/#day-2","title":"Day 2","text":"<p>Educational Codeforces Round 96</p> <ul> <li>cebolinha: \\(2088 + 121 = 2209\\)</li> <li>EYZ: \\(1535 + 20 = 1555\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_1","title":"Upsolving Quirino","text":"<ul> <li> G - Yet Another DAG Problem</li> </ul>"},{"location":"meta/vedj/#day-3","title":"Day 3","text":"<p>No virtual required since there was AtCoder, Codeforces and Mineira Marathon.</p>"},{"location":"meta/vedj/#upsolving-quirino_2","title":"Upsolving Quirino","text":"<ul> <li> L - Bacon e a \u00c1rvore M\u00e1gica</li> <li> N - Trapa\u00e7a na Pastelaria</li> </ul>"},{"location":"meta/vedj/#day-4","title":"Day 4","text":"<p>Educational Codeforces Round 144</p> <ul> <li>cebolinha: \\(2209 + 37 = 2246\\)</li> <li>EYZ: \\(1555 - 58 = 1497\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_3","title":"Upsolving Quirino","text":"<ul> <li> E - Colored Subgraphs</li> <li> F - Strange Triples</li> </ul>"},{"location":"meta/vedj/#day-5","title":"Day 5","text":"<p>Educational Codeforces Round 148</p> <ul> <li>cebolinha: \\(2246 + 87 = 2333\\)</li> <li>EYZ: \\(1497 - 19 = 1478\\)</li> </ul>"},{"location":"meta/vedj/#upsolving-quirino_4","title":"Upsolving Quirino","text":"<ul> <li> F - Zombies</li> </ul>"},{"location":"meta/winter/","title":"Winter Training \u2603\ufe0f","text":""},{"location":"meta/winter/#plans","title":"Plans","text":""},{"location":"meta/winter/#2023-08-15","title":"2023-08-15","text":"<ul> <li>CerealCodes contest in the afternoon.<ul> <li>Disastrous performance</li> <li>Solved two questions, wasted a lot of time on silly stuff</li> <li>Probably could solve C as well. On a very good day even D and E.</li> </ul> </li> <li>edu's Yellow Challenge #8 at night.<ul> <li>Pretty nice problems. One of them was on a Gym so I got it for free.</li> </ul> </li> <li>Upsolve ST and TS Palindrome from edu's Cyan Challenge! #1<ul> <li>Not too bad after all :P</li> </ul> </li> </ul>"},{"location":"meta/winter/#2023-08-16","title":"2023-08-16","text":"<ul> <li>RTTR #2 in the morning.</li> <li>A single AtCoder yellow.</li> <li>UNICAMP Selection Contest 2023 in the afternoon.</li> </ul>"},{"location":"meta/winter/#assorted-problems","title":"Assorted Problems","text":"<ul> <li> Prefix Function Queries</li> <li> Anthem of Berland</li> <li> Bottle Arrangements</li> </ul>"},{"location":"meta/winter/#tree-isomorphism-saga","title":"Tree Isomorphism Saga","text":"<ul> <li> Tree Isomorphism I</li> <li> Regular Forestation</li> <li> Generator Tree</li> <li> Favorite Tree</li> </ul>"},{"location":"meta/winter/#dsu-on-trees-saga","title":"DSU on Trees Saga","text":"<ul> <li> Blood Cousins Return</li> <li> Tree-String Problem</li> <li> Dominant Indices</li> <li> Digit Tree</li> <li> Arpa\u2019s letter-marked tree and Mehrdad\u2019s Dokhtar-kosh paths</li> </ul>"},{"location":"meta/winter/#ponder","title":"Ponder","text":"<ul> <li>Why are the at most two centroids?</li> </ul>"},{"location":"meta/blog/purr/","title":"Purr","text":"<p>Available on Codeforces. Pretty simple technique but found it useful a couple times.</p>"},{"location":"meta/blog/purr/#purr-packing-under-range-regulations","title":"Purr =^..^= Packing Under Range Regulations","text":"<p>This is a simple and educational greedy solution to an AtCoder problem.</p> <p>The following is (abc214_e) Packing Under Range Regulations: (slightly modified)</p>"},{"location":"meta/blog/purr/#problem-statement","title":"Problem Statement","text":"<p>There are \\(10^9\\) boxes numbered \\(1, 2, \\ldots, 10^9\\) and \\(N\\) balls numbered \\(1, 2, \\ldots, N\\).</p> <p>Each box can contain at most one ball.</p> <p>Determine whether it is possible to put all \\(N\\) balls in the boxes so that the following condition will be satisfied.</p> <ul> <li>For each integer \\(i\\) from \\(1\\) through \\(N\\), the ball numbered \\(i\\) is in a box numbered between \\(L_i\\) and \\(R_i\\) (inclusive).</li> </ul>"},{"location":"meta/blog/purr/#constraints","title":"Constraints","text":"<ul> <li>\\(1 \\leq N \\leq 2 \\times 10^5\\)</li> <li>\\(1 \\leq L_i \\leq R_i \\times 10^9\\)</li> </ul>"},{"location":"meta/blog/purr/#how-to-solve-it","title":"How to solve it","text":"<p>I suggest you try your best to solve the problem before continuining.</p>"},{"location":"meta/blog/purr/#my-initial-solution","title":"My initial solution","text":"<p>Initially, I tried a more complicated solution based on Hall's Marriage Theorem. However, the problem's editorial outlines a much more elegant solution that we will discuss.</p>"},{"location":"meta/blog/purr/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>Imagine you're walking along the boxes from \\(1\\) to \\(10^9\\) without turning back. Some of the boxes may have people behind them, each holding a ball to give you. The person with ball \\(i\\) is behind box \\(L_i\\). Whenever you encounter a person, you take the ball they're holding.</p> <p>At any moment you can place any ball you're holding into the box in front of you, including the one just given to you. However, each box can only hold one ball.</p> <p>But there's a twist: each ball is actually a ticking bomb. Ball \\(i\\) is a bomb that will explode and kill you if you don't put it into a box before passing position \\(R_i\\).</p>"},{"location":"meta/blog/purr/#understanding-the-greedy","title":"Understanding the Greedy","text":"<p>The story above is equivalent to the initial problem statement, but presenting it like this helps make the greedy solution more intuitive.</p> <p>There's never a point in leaving a box empty if you're holding any bombs. You won't be able to come back to it later and leave a bomb there, so you might as well take some weight off your back right now. However, you still have a choice to make: which of the bombs should you discard?</p> <p>For example, imagine you're holding three bombs that will explode at times \\(7\\), \\(8\\), and \\(10\\). You can discard a single bomb. Which one should you choose?</p> <p>The correct approach is to always get rid of the bomb closest to exploding. Although this may not be strictly necessary, there's no reason not to do it. It's intuitive to see how this is correct, but let's provide a proof for completeness:</p>"},{"location":"meta/blog/purr/#proof","title":"Proof","text":"<p>Consider a configuration of bomb choices where no bombs explode. Let's say that at some point, instead of discarding the bomb closer to exploding, denoted as \\(X\\), you discard some other bomb \\(Y\\) that would explode later. You only discard \\(X\\) at a later time.</p> <p>If we switch the positions of bombs \\(X\\) and \\(Y\\), we would still have a valid configuration. \\(X\\) would be discarded earlier than before, so it clearly still wouldn't explode. \\(Y\\) would be discarded later, but it would be discarded in position where \\(X\\) still wouldn't have exploded, and \\(X\\) explodes earlier than \\(Y\\).</p> <p>With this switch, we obtain a configuration with less \"inversions\", meaning there are fewer positions where we chose the \"wrong\" bomb. By repeating this process, we can transform any valid configuration into the one we would get using our greedy approach, without ever making it invalid. Therefore, if a solution exists, our greedy approach is a valid solution.</p>"},{"location":"meta/blog/purr/#implementation","title":"Implementation","text":"<p>The implementation consists of simulating the situation described above, resulting in an \\(\\mathcal{O}(N\\log N)\\) solution. The \\(\\log N\\) factor comes from sorting the balls in our inventory, for example, using a priority queue.</p> <p>We start from position \\(1\\) and iterate through the positions up to \\(10^9\\), taking any balls we encounter and discarding them as possible. Always picking the bomb closer to exploding. If any bomb explodes, there's no solution.</p> <p>It is important to note that if our inventory is empty, we should skip to the next box where you'll be given a ball.</p> <p>If you get stuck, refer to the problem's editorial, where a nice implementation can be found.</p>"},{"location":"meta/blog/purr/#other-problems","title":"Other problems","text":"<p>Here are two problems that can be solved if you're able to reduce them to Purr:</p> <ul> <li>(agc008_d) Kth-K</li> <li>(CF555_b) Case of Fugitive</li> </ul> <p>Curiously, a few days after I wrote this blog, this technique showed up in an AtCoder Beginner Contest:</p> <ul> <li>(abc304_h) Constrained Topological Sort</li> </ul>"},{"location":"meta/editorial/unbdesc2023/","title":"UnBDESC 2023","text":"<p>Link para submeter as quest\u00f5es</p>"},{"location":"meta/editorial/unbdesc2023/#fibonacci-string","title":"Fibonacci String","text":"<p>Podemos pr\u00e9-calcular facilmente quantas letras temos em \\(F_0, F_1, F_2\\dots\\), esse ser\u00e1 o vetor <code>AB</code> abaixo. Tamb\u00e9m guardaremos o tamanho de cada uma dessas palavras em <code>LEN</code>.</p> <p>Queremos saber as quantidades de \\(a\\) e \\(b\\) em \\(\\mathcal{F}[L, R]\\). Podemos fazer isso conseguindo essas quantidades em \\(\\mathcal{F}[0,R]\\) e removendo as quantidades em \\(\\mathcal{F}[0,L-1]\\).</p> <p>Quando pegamos um prefixo de \\(\\mathcal{F}\\), vamos pegar v\u00e1rias strings completas, mais um prefixo de uma palavra que ficou incompleta. Fazemos isso na fun\u00e7\u00e3o <code>ab_count</code>, que adiciona as letras de palavras completas enquanto o total n\u00e3o ultrapassa a quantidade de letras que queremos. No fim, ela chama a fun\u00e7\u00e3o <code>word_prefix</code> que acha a quantidade de cada letra num prefixo dessa palavra incompleta.</p> <p>A fun\u00e7\u00e3o <code>word_prefix</code> tem dois casos base. Se o prefixo que queremos tem tamanho \\(0\\), as quantidades s\u00e3o \\(0\\). Al\u00e9m disso, criamos casos especiais para a primeira e a segunda palavra.</p> <p>O principal fato que deve ser notado \u00e9 que como \\(F_k = F_{k-1} \\oplus F_{k-2}\\), se temos um prefixo de \\(F_k\\) que \u00e9 menor ou igual \u00e0 \\(F_{k-1}\\), ele \u00e9 equivalente \u00e0 um prefixo do mesmo tamanho de \\(F_{k-1}\\). Sen\u00e3o, ele \u00e9 \\(F_{k-1}\\) por completo, mais um prefixo de \\(F_{k-2}\\). Assim, podemos definir <code>word_prefix</code> recursivamente de uma forma simples.</p> <p>Complexidade: \\(\\mathcal{O}(\\log_\\varphi R)\\)? \u00c9 t\u00e3o r\u00e1pido que nem importa</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define int long long\n\npair&lt;int, int&gt; operator+(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\n  return {a.first + b.first, a.second + b.second};\n}\n\nconst int MAXF = 86;\npair&lt;int, int&gt; AB[MAXF];\nint LEN[MAXF];\n\npair&lt;int, int&gt; word_prefix(int idx, int len) {\n  if (len == 0) return {0, 0};\n  if (idx == 0 || idx == 1) return AB[idx];\n  if (len &lt;= LEN[idx-1]) return word_prefix(idx-1, len);\n  return AB[idx-1] + word_prefix(idx-2, len-LEN[idx-1]);\n}\n\npair&lt;int, int&gt; ab_count(int prefix_len) {\n  int idx = 0;\n  int len = 0;\n  pair&lt;int, int&gt; ab{0, 0};\n\n  while (len + LEN[idx] &lt;= prefix_len) {\n    ab = ab + AB[idx];\n    len += LEN[idx];\n    idx++;\n  }\n\n  int left = prefix_len - len;\n  return ab + word_prefix(idx, left);\n}\n\nsigned main() {\n  AB[0] = {0, 1}; LEN[0] = 1;\n  AB[1] = {1, 0}; LEN[1] = 1;\n  for (int i = 2; i &lt; MAXF; i++) {\n    AB[i] = AB[i-1] + AB[i-2];\n    LEN[i] = LEN[i-1] + LEN[i-2];\n  }\n\n  int l, r;\n  cin &gt;&gt; l &gt;&gt; r;\n\n  auto [ra, rb] = ab_count(r+1);\n  auto [la, lb] = ab_count(l);\n\n  cout &lt;&lt; ra-la &lt;&lt; ' ' &lt;&lt; rb-lb &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#interruptores","title":"Interruptores","text":"<p>Para simplificar o c\u00f3digo, convertemos os valores do vetor de \\((1, 0, -1)\\) para \\((0, 1, 2)\\).</p> <p>Fazemos uma DP que guarda para \\((i, j)\\) o menor custo para obter \\(A_0 \\dots A_i\\) com \\(A_i = j\\). A DP \u00e9 baseada do fato que para obter \\(A_0 \\dots A_i\\), devemos primeiro obter \\(A_0 \\dots A_{i-1}\\) com \\(A_{i-1} = j \\text{ ou } j-1\\) e depois adicionar \\(A_i = j\\). Devemos somar o custo \\(1\\) para mudar o estado do interruptor caso \\(A_i \\neq j\\).</p> <p>Para \\(i=0\\) temos os casos base: \\(D_{(0,0)} = A_0 \\neq 0, D_{(0, 1)} = \\infty, D_{(0, 2)} = \\infty\\).</p> <p>Para \\(i&gt;0\\), temos:</p> \\[ D_{(i, j)} = min \\begin{cases}     D_{(i-1, j)}\\\\     D_{(i-1, j-1)} \\text{ para } j &gt; 0 \\end{cases} + (A_i \\neq j) \\] <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint n;\nint A[100'000 + 8];\nint DP[100'000 + 8][3];\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(nullptr);\n\n  cin &gt;&gt; n;\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; A[i];\n    if (A[i] == +1) A[i] = 0;\n    else if (A[i] ==  0) A[i] = 1;\n    else if (A[i] == -1) A[i] = 2;\n  }\n\n  DP[0][0] = (A[0] != 0);\n  DP[0][1] = DP[0][2] = INF;\n  for (int i = 1; i &lt; n; i++) {\n    for (int j = 0; j &lt; 3; j++) {\n      DP[i][j] = DP[i-1][j] + (A[i] != j);\n      if (j-1 &gt;= 0) {\n        DP[i][j] = min(DP[i][j], DP[i-1][j-1] + (A[i] != j));\n      }\n    }\n  }\n\n  cout &lt;&lt; DP[n-1][2] &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#jovem-aprendiz","title":"Jovem Aprendiz","text":"<p>Essa foi a quest\u00e3o com mais submiss\u00f5es da prova (151, ou 31.0%). Foram 12 RTEs, 35 TLEs, 74 WAs e 30 ACs.</p> <p>Muitos dos WAs foram causados por overflows, que podem ser resolvidos trocando <code>int</code> por <code>long long</code>.</p> <p>Os TLEs foram causados pelo fato da solu\u00e7\u00e3o \"naive\" n\u00e3o ser r\u00e1pida o suficiente. Se o monstro tem muita vida (como \\(10^{18}\\)) e os ataques s\u00e3o muito fracos (como \\(1\\) ou \\(2\\)), \u00e9 necess\u00e1ria uma quantidade enorme de ataques para matar o monstro.</p> <p>Um jeito de resolver isso \u00e9 pr\u00e9-calcular a soma dos danos dos \\(N\\) ataques. Digamos que o monstro tem \\(5000\\) de vida e os \\(N\\) ataques d\u00e3o \\(17\\) de dano no total. Podemos ver que o mago usar\u00e1 um ciclo de todos seus ataques pelo menos \\(\\lfloor5000/17\\rfloor = 294\\) vezes. Depois disso resta \\(2\\) de vida, e podemos ir aplicando os ataques um por um enquanto o monstro n\u00e3o morrer.</p> <p>A quantidade de ataques que vai restar ap\u00f3s retirarmos os ciclos completos \u00e9 sempre menor ou igual \u00e0 \\(N\\), pois a vida que sobra \u00e9 menor que o dano de um ciclo de ataques. Assim o loop que vai aplicando o dano de cada ataque enquanto o monstro estiver vivo n\u00e3o vai rodar mais do que \\(N\\) vezes, sendo r\u00e1pido o suficiente.</p> <p>Complexidade: \\(\\mathcal{O}(N)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nlong long A[100'000 + 8];\n\nint main() {\n  long long n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n\n  long long sum = 0;\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; A[i];\n    sum += A[i];\n  }\n\n  long long ans = (m/sum) * n;\n  m %= sum;\n\n  for (int i = 0; i &lt; n; i++) {\n    m -= A[i];\n    ans++;\n    if (m &lt;= 0) break;\n  }\n\n  cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre>"},{"location":"meta/editorial/unbdesc2023/#keyboard","title":"Keyboard","text":"<p>O enunciado n\u00e3o garante que n\u00e3o v\u00e3o ter dois n\u00fameros iguais seguidos na sequ\u00eancia de digita\u00e7\u00e3o. O jeito mais f\u00e1cil de lidar com isso \u00e9 quando for ler a sequ\u00eancia ignorar os n\u00fameros que s\u00e3o iguais ao n\u00famero anterior.</p> <p>Depois disso \u00e9 s\u00f3 fazer uma BFS, onde em vez do estado ser \\((i, j)\\), ele \u00e9 \\((i, j, \\text{done})\\), onde \\(\\text{done}\\) \u00e9 a quantidade de itens da sequ\u00eancia que j\u00e1 foram satisfeitos. O c\u00f3digo abaixo \u00e9 bem auto-explicativo.</p> <p>Complexidade: \\(\\mathcal{O}(N\\cdot M\\cdot Q)\\)</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst vector&lt;pair&lt;int, int&gt;&gt; delta{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n\n  vector grid(n, vector&lt;int&gt;(m));\n  for (int i = 0; i &lt; n; i++)\n    for (int j = 0; j &lt; m; j++)\n      cin &gt;&gt; grid[i][j];\n\n  int q; cin &gt;&gt; q;\n  vector&lt;int&gt; path;\n  for (int i = 0; i &lt; q; i++) {\n    int x; cin &gt;&gt; x;\n    if (path.empty() || path.back() != x)\n      path.push_back(x);\n  }\n  q = size(path);\n\n  vector dist(n, vector(m, vector&lt;int&gt;(q+1, -1)));\n\n  queue&lt;array&lt;int, 4&gt;&gt; Q;\n\n  int first_done = path[0] == grid[0][0];\n  Q.push({0, 0, 0, first_done});\n\n  while (!Q.empty()) {\n    auto [vd, vi, vj, vdone] = Q.front(); Q.pop();\n    if (vdone == q) return cout &lt;&lt; vd &lt;&lt; endl, 0;\n\n    for (auto [di, dj] : delta) {\n      int ui = vi + di, uj = vj + dj;\n      if (!(0 &lt;= ui &amp;&amp; ui &lt; n)) continue;\n      if (!(0 &lt;= uj &amp;&amp; uj &lt; m)) continue;\n\n      int udone = vdone + (grid[ui][uj] == path[vdone]);\n      if (dist[ui][uj][udone] == -1) {\n        dist[ui][uj][udone] = vd + 1;\n        Q.push({vd+1, ui, uj, udone});\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"string/hashed_string/","title":"Hashed String","text":""},{"location":"string/hashed_string/#code","title":"Code","text":"Hashed String<pre><code>// Hashed String {{{\nclass HashedString {\n    static const int M = (1LL &lt;&lt; 61) - 1;\n    static const int B;\n\n    static V&lt;int&gt; pow;\n\n    V&lt;int&gt; p_hash;\n\n    __int128 mul(int a, int b) { return (__int128)a * b; }\n    int mod_mul(int a, int b) { return mul(a, b) % M; }\n\npublic:\n    explicit HashedString(string const&amp; s) {\n        while (size(pow) &lt; size(s) + 1) pow.push_back(mod_mul(pow.back(), B));\n\n    p_hash.resize(size(s) + 1);\n        p_hash[0] = 0;\n        for (int i = 0; i &lt; size(s); i++) {\n            p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;\n        }\n    }\n\n    int get_hash(int start, int end) {\n        int raw_val = p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);\n        return (raw_val + M) % M;\n    }\n};\nV&lt;int&gt; HashedString::pow = {1};\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\nconst int HashedString::B = uniform_int_distribution&lt;int&gt;(0, M - 1)(rng);\n//}}}\n</code></pre>"},{"location":"string/prefix_function/","title":"Prefix Function","text":""},{"location":"string/prefix_function/#code","title":"Code","text":"Prefix Function<pre><code>// Prefix Function {{{\nvector&lt;int&gt; prefix_function(string const&amp; S) {\n  int N = size(S);\n  vector&lt;int&gt; pi(N);\n  for (int i = 1; i &lt; N; i++) {\n    int j = pi[i-1];\n    while (j &gt; 0 &amp;&amp; S[i] != S[j]) j = pi[j-1];\n    if (S[i] == S[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\n//}}}\n</code></pre>"},{"location":"string/suffix_array/","title":"Suffix Array","text":""},{"location":"string/suffix_array/#code","title":"Code","text":"Suffix Array<pre><code>// Suffix Array {{{\nvector&lt;int&gt; sort_cyclic_shifts(string const&amp; s) {\n  int N = s.size();\n\n  vector&lt;int&gt; p(N);\n  iota(begin(p), end(p), 0);\n  sort(begin(p), end(p), [&amp;](int x, int y) {\n    return s[x] &lt; s[y];\n  });\n\n  vector&lt;int&gt; eq(N);\n  eq[p[0]] = 0;\n  for (int i = 1; i &lt; N; i++)\n    eq[p[i]] = eq[p[i - 1]] + (s[p[i]] != s[p[i - 1]]);\n\n  for (int shift = 1; shift &lt; N; shift *= 2) {\n    vector&lt;int&gt; cnt(N);\n    for (int i = 0; i &lt; N; i++)\n      cnt[eq[i]]++;\n    partial_sum(begin(cnt), end(cnt), begin(cnt));\n\n    vector&lt;int&gt; tmp(N);\n    for (int i = 0; i &lt; N; i++)\n      tmp[N - 1 - i] = (p[i] - shift + N) % N;\n    for (auto i : tmp)\n      p[--cnt[eq[i]]] = i;\n\n    auto key = [&amp;](int x) {\n      return pair(eq[x], eq[(x + shift) % N]);\n    };\n\n    tmp[p[0]] = 0;\n    for (int i = 1; i &lt; N; i++)\n      tmp[p[i]] = tmp[p[i - 1]] + (key(p[i]) != key(p[i - 1]));\n    swap(tmp, eq);\n  }\n\n  return p;\n}\n\nvector&lt;int&gt; suffix_array(string s) {\n  s += '$';\n  return sort_cyclic_shifts(s);\n}\n\nvector&lt;int&gt; kasai(string const&amp; s, vector&lt;int&gt; const&amp; p) {\n  int N = size(s);\n  vector&lt;int&gt; rank(N);\n  for (int i = 0; i &lt; N; i++)\n    rank[p[i]] = i;\n\n  int k = 0;\n  vector&lt;int&gt; lcp(N-1);\n  for (int i = 0; i &lt; N; i++) {\n    if (rank[i] == N-1) {\n      k = 0;\n      continue;\n    }\n    int j = p[rank[i] + 1];\n    while (i + k &lt; N &amp;&amp; j + k &lt; N &amp;&amp; s[i+k] == s[j+k]) k++;\n    lcp[rank[i]] = k;\n    if (k) k--;\n  }\n\n  return lcp;\n}\n//}}}\n</code></pre>"},{"location":"string/trie/","title":"Trie","text":""},{"location":"string/trie/#code","title":"Code","text":"Trie<pre><code>// Trie {{{\nstruct Trie {\n  const int MALPHA = 26;\n\n  vector&lt;vector&lt;int&gt;&gt; trie{vector&lt;int&gt;(MALPHA, -1)};\n  vector&lt;int&gt; word_cnt{0};\n\n  int add_node() {\n    trie.push_back(vector&lt;int&gt;(MALPHA, -1));\n    word_cnt.push_back(0);\n    return size(trie)-1;\n  }\n\n  void insert(string const&amp; s) {\n    int cur = 0;\n    for (auto c : s) {\n      if (trie[cur][c-'a'] == -1)\n        trie[cur][c-'a'] = add_node();\n      cur = trie[cur][c-'a'];\n    }\n    word_cnt[cur]++;\n  }\n\n  int count(string const&amp; s) {\n    int cur = 0;\n    for (auto c : s) {\n      if (trie[cur][c-'a'] == -1)\n        return false;\n      cur = trie[cur][c-'a'];\n    }\n    return word_cnt[cur];\n  }\n};\n//}}}\n</code></pre>"},{"location":"string/trie/#problems","title":"Problems","text":"<ul> <li>(CF456-D) A Lot of Games</li> </ul>"},{"location":"string/z_function/","title":"Z-Function","text":""},{"location":"string/z_function/#code","title":"Code","text":"Z-Function<pre><code>// Z-Function {{{\nvector&lt;int&gt; z_function(string const&amp; S) {\n  int N = size(S);\n  vector&lt;int&gt; z(N);\n  int l = 0, r = 0 ;\n  for (int i = 1; i &lt; N; i++) {\n    if (i &lt; r) z[i] = min(r-i, z[i-l]);\n    while (i + z[i] &lt; N &amp;&amp; S[z[i]] == S[i+z[i]]) z[i]++;\n    if (i + z[i] &gt; r) {\n      l = i;\n      r = i+z[i];\n    }\n  }\n  return z;\n}\n//}}}\n</code></pre>"}]}